<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rives' reMarkable Templates for Book Publishing</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .controls label {
            margin-right: 15px;
            font-weight: bold;
        }
        
        .controls select, .controls button {
            padding: 8px 12px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        
        .controls button {
            background: #007bff;
            color: white;
            border: none;
            cursor: pointer;
        }
        
        .controls button:hover {
            background: #0056b3;
        }
        
        .template-container {
            background: #f0f0f0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 0 auto;
        }
        
        .template-page {
            width: 1872px;
            height: 1404px;
            background: #f5f5f5;
            position: relative;
            margin: 0 auto;
        }
        
        .border-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 1;
        }
        
        .content-area {
            position: absolute;
            background: white;
            z-index: 0;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
        
        .margin-lines {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 2;
        }

        .gutter-margin {
            position: absolute;
            top: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 3;
        }

        .margin-text {
            position: absolute;
            font-family: Arial, sans-serif;
            color: rgba(100, 100, 100, 0.4);
            font-size: 11px;
            font-weight: normal;
            pointer-events: none;
            z-index: 5;
            white-space: nowrap;
            display: none;
        }

        .margin-text.vertical {
            writing-mode: vertical-rl;
            transform: rotate(180deg);
        }
        
        .url-text {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #999;
            font-family: Arial, sans-serif;
            z-index: 3;
            pointer-events: none;
        }
        
        .margin-label-top {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #666;
            font-family: Arial, sans-serif;
            font-weight: bold;
            z-index: 4;
            pointer-events: none;
            display: none;
        }
        
        .margin-label-right {
            position: absolute;
            transform: rotate(-90deg);
            transform-origin: center;
            font-size: 10px;
            color: #666;
            font-family: Arial, sans-serif;
            font-weight: bold;
            z-index: 4;
            pointer-events: none;
            display: none;
            white-space: nowrap;
        }
        
        .ruler-left {
            position: absolute;
            left: 2px;
            top: 0;
            bottom: 0;
            width: 20px;
            font-size: 7px;
            font-family: Arial, sans-serif;
            color: #666;
            z-index: 3;
            pointer-events: none;
            display: none;
        }
        
        .ruler-bottom {
            position: absolute;
            left: 0;
            right: 0;
            bottom: 2px;
            height: 20px;
            font-size: 7px;
            font-family: Arial, sans-serif;
            color: #666;
            z-index: 3;
            pointer-events: none;
            display: none;
        }
        
        .ruler-mark {
            position: absolute;
            white-space: nowrap;
        }
        
        .ruler-left .ruler-mark {
            left: 0;
            transform: translateY(-50%);
        }
        
        .ruler-bottom .ruler-mark {
            bottom: 0;
            transform: translateX(-50%);
        }
        
        .grid-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            -webkit-print-color-adjust: exact;
            print-color-adjust: exact;
        }
        
        .lined {
            background-color: white;
        }
        
        .grid {
            background-color: white;
        }
        
        .dot-grid {
            background-color: white;
        }
        
        .blank {
            background: white;
        }
        
        .cornell {
            background: white;
            position: relative;
        }
        
        .cornell::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 150px;
            width: 30%;
            border-right: 2px solid #c0c0c0;
        }
        
        .cornell::after {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            bottom: 150px;
            height: 2px;
            background: #c0c0c0;
        }
        
        .music {
            background-image: repeating-linear-gradient(
                transparent,
                transparent 100px,
                #d0d0d0 100px,
                #d0d0d0 101px,
                transparent 101px,
                transparent 120px,
                #d0d0d0 120px,
                #d0d0d0 121px,
                transparent 121px,
                transparent 140px,
                #d0d0d0 140px,
                #d0d0d0 141px,
                transparent 141px,
                transparent 160px,
                #d0d0d0 160px,
                #d0d0d0 161px,
                transparent 161px,
                transparent 180px,
                #d0d0d0 180px,
                #d0d0d0 181px,
                transparent 181px,
                transparent 250px
            );
        }
        
        @media print {
            body {
                margin: 0;
                padding: 0;
                background: white;
            }

            .controls {
                display: none;
            }

            .info {
                display: none;
            }

            .page-separator {
                display: none;
            }

            .page-subtitle {
                display: none;
            }

            #togglePageBtn {
                display: none;
            }

            #pageTypeLabel {
                display: none;
            }

            .template-container {
                box-shadow: none;
                margin: 0;
                padding: 0;
            }

            .template-page {
                page-break-after: always;
                margin: 0;
            }

            .content-area {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
            }

            .ruler-left, .ruler-bottom {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
                color-adjust: exact !important;
            }
        }
        
        .info {
            margin-top: 20px;
            padding: 15px;
            background: #e7f3ff;
            border-left: 4px solid #007bff;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h2 style="margin: 0 0 5px 0; color: #333; text-align: center; font-style: italic; font-weight: normal;">Rives' reMarkable Templates for Book Publishing</h2>
        <p style="margin: 0 0 15px 0; color: #666; text-align: center; font-size: 14px;">Useful for minding your margins on any reMarkable</p>
        
        <div style="margin-bottom: 10px;">
            <label for="deviceType">Device:</label>
            <select id="deviceType">
                <option value="rm2">reMarkable 1/2</option>
                <option value="rmpro" selected>reMarkable Pro</option>
                <option value="paperpromove">Paper Pro Move</option>
            </select>

            <label for="pageSize" style="margin-left: 20px;">Page Size:</label>
            <select id="pageSize">
                <option value="1620,2160">Full reMarkable Pro (7.07" × 9.43")</option>
            </select>

            <label for="scaleType" style="margin-left: 20px;">Scale by DPI:</label>
            <select id="scaleType">
                <option value="yes" selected>Yes</option>
                <option value="no">No</option>
            </select>

            <label for="centeringMarginColor" id="centeringMarginColorLabel" style="margin-left: 10px;">Page Centering Margin Color:</label>
            <select id="centeringMarginColor" style="padding: 4px;">
                <option value="rgba(0, 0, 0, 0.15)" style="color: rgba(0, 0, 0, 0.7);">Dark Gray</option>
                <option value="rgba(128, 128, 128, 0.15)" style="color: rgba(128, 128, 128, 0.7);">Medium Gray</option>
                <option value="rgba(200, 200, 200, 0.15)" style="color: rgba(200, 200, 200, 0.7);">Light Gray</option>
                <option value="rgba(173, 216, 230, 0.2)" style="color: rgb(100, 180, 220);">Light Blue</option>
                <option value="rgba(100, 149, 237, 0.2)" style="color: rgb(100, 149, 237);">Medium Blue</option>
                <option value="rgba(255, 182, 193, 0.2)" style="color: rgb(255, 100, 150);">Light Pink</option>
                <option value="rgba(255, 255, 200, 0.2)" style="color: rgb(200, 200, 100);">Light Yellow</option>
                <option value="rgba(144, 238, 144, 0.2)" style="color: rgb(100, 200, 100);">Light Green</option>
            </select>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label for="bindingType">Binding Type:</label>
            <select id="bindingType">
                <option value="perfect">Perfect Binding (Glued)</option>
                <option value="saddle">Saddle Stitch (Stapled)</option>
                <option value="spiral">Spiral/Coil Binding</option>
                <option value="wireo">Wire-O Binding</option>
                <option value="case">Case Binding (Hardcover)</option>
            </select>

            <label for="platform" style="margin-left: 20px;">Publisher/Platform:</label>
            <select id="platform">
                <option value="general">General Publishing</option>
                <option value="kdp">Amazon KDP</option>
                <option value="ingram">IngramSpark</option>
                <option value="lulu">Lulu</option>
                <option value="bn">Barnes & Noble Press</option>
                <option value="d2d">Draft2Digital</option>
                <option value="blurb">Blurb</option>
                <option value="bookbaby">BookBaby</option>
                <option value="canva">Canva Print</option>
            </select>

            <label for="showMarginTexts" style="margin-left: 20px;">
                <input type="checkbox" id="showMarginTexts">
                Show Margin Texts
            </label>

            <button onclick="applyRecommendedMargins()" style="margin-left: 20px; padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; background: #28a745; color: white; cursor: pointer;">Apply Margin Recommendations</button>
        </div>
        
        <div id="marginRecommendation" style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-left: 4px solid #28a745; border-radius: 4px; font-size: 13px; display: none;">
            <strong>Recommended Margins:</strong><br><br>
            <span id="recommendationText"></span>
        </div>
        
        <div style="margin-bottom: 10px;">
            <label for="marginTop">Margins - Top:</label>
            <select id="marginTop">
                <option value="0">0"</option>
                <option value="11.3">0.05"</option>
                <option value="22.6">0.10"</option>
                <option value="33.9">0.15"</option>
                <option value="45.2">0.20"</option>
                <option value="56.5">0.25"</option>
                <option value="67.8">0.30"</option>
                <option value="79.1">0.35"</option>
                <option value="90.4">0.40"</option>
                <option value="101.7">0.45"</option>
                <option value="113">0.50"</option>
                <option value="124.3">0.55"</option>
                <option value="135.6">0.60"</option>
                <option value="146.9">0.65"</option>
                <option value="158.2">0.70"</option>
                <option value="169.5" selected>0.75"</option>
                <option value="180.8">0.80"</option>
                <option value="192.1">0.85"</option>
                <option value="203.4">0.90"</option>
                <option value="214.7">0.95"</option>
                <option value="226">1.00"</option>
                <option value="237.3">1.05"</option>
                <option value="248.6">1.10"</option>
                <option value="259.9">1.15"</option>
                <option value="271.2">1.20"</option>
                <option value="282.5">1.25"</option>
                <option value="293.8">1.30"</option>
                <option value="305.1">1.35"</option>
                <option value="316.4">1.40"</option>
                <option value="327.7">1.45"</option>
                <option value="339">1.50"</option>
            </select>
            
            <label for="marginBottom" style="margin-left: 10px;">Bottom:</label>
            <select id="marginBottom">
                <option value="0">0"</option>
                <option value="11.3">0.05"</option>
                <option value="22.6">0.10"</option>
                <option value="33.9">0.15"</option>
                <option value="45.2">0.20"</option>
                <option value="56.5">0.25"</option>
                <option value="67.8">0.30"</option>
                <option value="79.1">0.35"</option>
                <option value="90.4">0.40"</option>
                <option value="101.7">0.45"</option>
                <option value="113">0.50"</option>
                <option value="124.3">0.55"</option>
                <option value="135.6">0.60"</option>
                <option value="146.9">0.65"</option>
                <option value="158.2">0.70"</option>
                <option value="169.5" selected>0.75"</option>
                <option value="180.8">0.80"</option>
                <option value="192.1">0.85"</option>
                <option value="203.4">0.90"</option>
                <option value="214.7">0.95"</option>
                <option value="226">1.00"</option>
                <option value="237.3">1.05"</option>
                <option value="248.6">1.10"</option>
                <option value="259.9">1.15"</option>
                <option value="271.2">1.20"</option>
                <option value="282.5">1.25"</option>
                <option value="293.8">1.30"</option>
                <option value="305.1">1.35"</option>
                <option value="316.4">1.40"</option>
                <option value="327.7">1.45"</option>
                <option value="339">1.50"</option>
            </select>
            
            <label for="marginLeft" style="margin-left: 10px;">Left:</label>
            <select id="marginLeft">
                <option value="0">0"</option>
                <option value="11.3">0.05"</option>
                <option value="22.6">0.10"</option>
                <option value="33.9">0.15"</option>
                <option value="45.2">0.20"</option>
                <option value="56.5">0.25"</option>
                <option value="67.8">0.30"</option>
                <option value="79.1">0.35"</option>
                <option value="90.4">0.40"</option>
                <option value="101.7">0.45"</option>
                <option value="113">0.50"</option>
                <option value="124.3">0.55"</option>
                <option value="135.6">0.60"</option>
                <option value="146.9">0.65"</option>
                <option value="158.2">0.70"</option>
                <option value="169.5" selected>0.75"</option>
                <option value="180.8">0.80"</option>
                <option value="192.1">0.85"</option>
                <option value="203.4">0.90"</option>
                <option value="214.7">0.95"</option>
                <option value="226">1.00"</option>
                <option value="237.3">1.05"</option>
                <option value="248.6">1.10"</option>
                <option value="259.9">1.15"</option>
                <option value="271.2">1.20"</option>
                <option value="282.5">1.25"</option>
                <option value="293.8">1.30"</option>
                <option value="305.1">1.35"</option>
                <option value="316.4">1.40"</option>
                <option value="327.7">1.45"</option>
                <option value="339">1.50"</option>
            </select>
            
            <label for="marginRight" style="margin-left: 10px;">Right:</label>
            <select id="marginRight">
                <option value="0">0"</option>
                <option value="11.3">0.05"</option>
                <option value="22.6">0.10"</option>
                <option value="33.9">0.15"</option>
                <option value="45.2">0.20"</option>
                <option value="56.5">0.25"</option>
                <option value="67.8">0.30"</option>
                <option value="79.1">0.35"</option>
                <option value="90.4">0.40"</option>
                <option value="101.7">0.45"</option>
                <option value="113">0.50"</option>
                <option value="124.3">0.55"</option>
                <option value="135.6">0.60"</option>
                <option value="146.9">0.65"</option>
                <option value="158.2">0.70"</option>
                <option value="169.5" selected>0.75"</option>
                <option value="180.8">0.80"</option>
                <option value="192.1">0.85"</option>
                <option value="203.4">0.90"</option>
                <option value="214.7">0.95"</option>
                <option value="226">1.00"</option>
                <option value="237.3">1.05"</option>
                <option value="248.6">1.10"</option>
                <option value="259.9">1.15"</option>
                <option value="271.2">1.20"</option>
                <option value="282.5">1.25"</option>
                <option value="293.8">1.30"</option>
                <option value="305.1">1.35"</option>
                <option value="316.4">1.40"</option>
                <option value="327.7">1.45"</option>
                <option value="339">1.50"</option>
            </select>

            <label for="marginColor" style="margin-left: 10px;">Margin Color:</label>
            <select id="marginColor" style="padding: 4px;">
                <option value="rgba(160, 160, 160, 0.3)" style="color: rgb(160, 160, 160);">Light Gray</option>
                <option value="rgba(100, 100, 100, 0.3)" style="color: rgb(100, 100, 100);">Medium Gray</option>
                <option value="rgba(60, 60, 60, 0.3)" style="color: rgb(60, 60, 60);">Dark Gray</option>
                <option value="rgba(255, 200, 200, 0.3)" style="color: rgb(255, 150, 150);">Light Red</option>
                <option value="rgba(255, 100, 100, 0.3)" style="color: rgb(255, 100, 100);">Medium Red</option>
                <option value="rgba(200, 50, 50, 0.3)" style="color: rgb(200, 50, 50);">Dark Red</option>
                <option value="rgba(255, 182, 193, 0.3)" style="color: rgb(255, 140, 160);">Light Pink</option>
                <option value="rgba(255, 105, 180, 0.3)" style="color: rgb(255, 105, 180);">Medium Pink</option>
                <option value="rgba(219, 112, 147, 0.3)" style="color: rgb(219, 112, 147);">Dark Pink</option>
                <option value="rgba(173, 216, 230, 0.3)" style="color: rgb(100, 180, 220);">Light Blue</option>
                <option value="rgba(100, 149, 237, 0.3)" style="color: rgb(100, 149, 237);">Medium Blue</option>
                <option value="rgba(65, 105, 225, 0.3)" style="color: rgb(65, 105, 225);">Dark Blue</option>
                <option value="rgba(255, 255, 200, 0.3)" style="color: rgb(200, 200, 100);">Light Yellow</option>
                <option value="rgba(255, 255, 100, 0.3)" style="color: rgb(200, 200, 50);">Medium Yellow</option>
                <option value="rgba(218, 165, 32, 0.3)" style="color: rgb(218, 165, 32);">Dark Yellow</option>
                <option value="rgba(144, 238, 144, 0.3)" style="color: rgb(100, 200, 100);">Light Green</option>
                <option value="rgba(60, 179, 113, 0.3)" style="color: rgb(60, 179, 113);">Medium Green</option>
                <option value="rgba(34, 139, 34, 0.3)" style="color: rgb(34, 139, 34);">Dark Green</option>
                <option value="rgba(221, 160, 221, 0.3)" style="color: rgb(200, 130, 200);">Light Purple</option>
                <option value="rgba(147, 112, 219, 0.3)" style="color: rgb(147, 112, 219);">Medium Purple</option>
                <option value="rgba(75, 0, 130, 0.3)" style="color: rgb(75, 0, 130);">Dark Purple</option>
                <option value="rgba(255, 218, 185, 0.3)" style="color: rgb(255, 180, 130);">Light Orange</option>
                <option value="rgba(255, 140, 0, 0.3)" style="color: rgb(255, 140, 0);">Medium Orange</option>
                <option value="rgba(255, 69, 0, 0.3)" style="color: rgb(255, 69, 0);">Dark Orange</option>
            </select>

            <button onclick="resetMargins()" style="margin-left: 10px; padding: 8px 12px; border-radius: 4px; border: 1px solid #ccc; background: #ff69b4; color: white; cursor: pointer;">Reset Margins</button>

            <span id="usableArea" style="margin-left: 20px; font-weight: bold; color: #007bff;"></span>
        </div>

        <div style="margin-bottom: 10px;">
            <input type="checkbox" id="useGutterMargins">
            <label for="useGutterMargins">Use Gutter Margins</label>

            <label for="gutterLeft" style="margin-left: 20px;">Left Side (Odd Page):</label>
            <select id="gutterLeft">
            </select>

            <label for="gutterRight" style="margin-left: 10px;">Right Side (Even Page):</label>
            <select id="gutterRight">
            </select>

            <label for="gutterColor" style="margin-left: 10px;">Gutter Color:</label>
            <select id="gutterColor" style="padding: 4px;">
                <option value="rgba(173, 216, 230, 0.4)" style="color: rgb(100, 180, 220);">Light Blue</option>
                <option value="rgba(100, 149, 237, 0.4)" style="color: rgb(100, 149, 237);">Medium Blue</option>
                <option value="rgba(65, 105, 225, 0.4)" style="color: rgb(65, 105, 225);">Dark Blue</option>
                <option value="rgba(255, 255, 200, 0.4)" style="color: rgb(200, 200, 100);">Light Yellow</option>
                <option value="rgba(255, 255, 100, 0.4)" style="color: rgb(200, 200, 50);">Medium Yellow</option>
                <option value="rgba(218, 165, 32, 0.4)" style="color: rgb(218, 165, 32);">Dark Yellow</option>
                <option value="rgba(144, 238, 144, 0.4)" style="color: rgb(100, 200, 100);">Light Green</option>
                <option value="rgba(60, 179, 113, 0.4)" style="color: rgb(60, 179, 113);">Medium Green</option>
                <option value="rgba(34, 139, 34, 0.4)" style="color: rgb(34, 139, 34);">Dark Green</option>
            </select>
        </div>

        <div>
            <label for="templateType">Template Type:</label>
            <select id="templateType">
                <option value="blank">Blank</option>
                <option value="lined">Lined</option>
                <option value="grid" selected>Grid</option>
                <option value="dot-grid">Dot Grid</option>
                <option value="cornell">Cornell Notes</option>
                <option value="music">Music Staff</option>
            </select>

            <label for="gridSize" id="gridSizeLabel" style="margin-left: 20px;">Line/Grid Size:</label>
            <select id="gridSize">
                <option value="11.3">0.05" (11px)</option>
                <option value="22.6" selected>0.10" (23px)</option>
                <option value="33.9">0.15" (34px)</option>
                <option value="45.2">0.20" (45px)</option>
                <option value="56.5">0.25" (57px)</option>
                <option value="67.8">0.30" (68px)</option>
                <option value="79.1">0.35" (79px)</option>
                <option value="90.4">0.40" (90px)</option>
                <option value="101.7">0.45" (102px)</option>
                <option value="113">0.50" (113px)</option>
                <option value="124.3">0.55" (124px)</option>
                <option value="135.6">0.60" (136px)</option>
                <option value="146.9">0.65" (147px)</option>
                <option value="158.2">0.70" (158px)</option>
                <option value="169.5">0.75" (170px)</option>
                <option value="180.8">0.80" (181px)</option>
                <option value="192.1">0.85" (192px)</option>
                <option value="203.4">0.90" (203px)</option>
                <option value="214.7">0.95" (215px)</option>
                <option value="226">1.00" (226px)</option>
                <option value="237.3">1.05" (237px)</option>
                <option value="248.6">1.10" (249px)</option>
                <option value="259.9">1.15" (260px)</option>
                <option value="271.2">1.20" (271px)</option>
                <option value="282.5">1.25" (283px)</option>
            </select>
            
            <label for="overlayGrid" id="overlayGridLabel" style="margin-left: 20px;">Overlay Every:</label>
            <select id="overlayGrid">
                <option value="0">None</option>
                <option value="2">2 squares</option>
                <option value="3">3 squares</option>
                <option value="4">4 squares</option>
                <option value="5" selected>5 squares</option>
                <option value="6">6 squares</option>
                <option value="7">7 squares</option>
                <option value="8">8 squares</option>
                <option value="9">9 squares</option>
                <option value="10">10 squares</option>
            </select>
            
            <label for="showRulers" style="margin-left: 20px;">Show Rulers:</label>
            <input type="checkbox" id="showRulers">

            <label for="showMarginDimensions" style="margin-left: 20px;">Show Wd × Ht:</label>
            <input type="checkbox" id="showMarginDimensions">

            <span id="rulerSizeLabel" style="margin-left: 20px; font-size: 11px; color: #666;">Text Size 10</span>
            <button onclick="decreaseRulerSize()" style="margin-left: 5px; padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">−</button>
            <button onclick="increaseRulerSize()" style="margin-left: 5px; padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">+</button>
        </div>

        <div style="margin-top: 10px;">
            <label for="pdfPageCount">Pages:</label>
            <select id="pdfPageCount" style="padding: 4px;">
            </select>
            <button onclick="savePDF()" style="background: #28a745; margin-left: 10px;">Save Workbook PDF</button>
            <button onclick="saveSVG()" style="background: #17a2b8; margin-left: 20px;">Save Template SVG</button>
            <button onclick="savePNG()" style="background: #ffc107; color: #000; margin-left: 10px;">Save Template PNG</button>
            <button onclick="saveMSWord()" style="background: #0078d4; color: white; margin-left: 20px;">Save MS-Word</button>
        </div>

        <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-left: 4px solid #6c757d; border-radius: 4px; font-size: 12px; font-family: monospace;">
            <strong>Debug:</strong> <span id="debugInfo" style="color: #495057;"></span>
        </div>
    </div>
    
    <div class="info">
        <strong>Instructions:</strong> <span style="color: #666; font-size: 12px; margin-left: 10px;">Version 1.0.2</span> 
        <ul style="margin: 10px 0; padding-left: 20px;">
            <li><strong>Device:</strong> Select your reMarkable device. This adjusts the canvas size and available page sizes.</li>
            <li><strong>Scale by DPI:</strong> DPI (Dots per Inch, aka PPI pixels per inch). Choose "Yes" for DPI-scaled page sizes or "No" to use the full device screen for the selected page size. When "No" is selected, the entire device canvas represents the physical page dimensions (e.g., selecting "6" × 9"" makes the full device screen represent a 6" × 9" page), no default margins are applied, and rulers/grids scale to match the selected physical dimensions. Scale set to No means that we use the actual tablet size. What you write on it will map to a PDF on export. When Scale is Yes (the default) you are writing the actual size as it will appear in the book.</li>
            <li><strong>Page Size:</strong> Select your target book/page size. Default publishing margins are automatically applied when Scale is "Yes".</li>
            <li><strong>Binding Type & Publisher/Platform:</strong> View margin recommendations for different binding types and publishing platforms. Click "Apply Recommended Margins" to use suggested defaults.</li>
            <li><strong>Margins:</strong> Adjust individual margins for top, bottom, left, and right (0" to 1.5" in 0.05" increments). Margins are shown with borders (gray for reMarkable 1/2, red for color devices). The usable area (width × height inside margins) is displayed next to the Right margin control.</li>
            <li><strong>Template Type:</strong> Select your preferred template style (lined, grid, dot grid, etc.).</li>
            <li><strong>Line/Grid Size:</strong> For lined, grid, or dot-grid templates, choose the spacing in inches (0.05" to 1.25").</li>
            <li><strong>Overlay Every:</strong> For grid/dot-grid templates, add darker lines/dots every N squares for major/minor grid divisions.</li>
            <li><strong>Show Rulers:</strong> Check this box to display inch measurements along the left and bottom edges (marks every 0.25").</li>
            <li><strong>Show Wd × Ht:</strong> Check this box to display the usable dimensions within the margin areas (width in top margin, height in right margin).</li>
            <li><strong>Export:</strong> Use "Save Workbook PDF" for print-ready PDFs (opens print dialog), "Save Template SVG" for vector format, "Save Template PNG" for raster images, or "Save MS-Word" to create a Microsoft Word document with cover page, front matter (TOC, dedication), and content pages with proper margins. The Word document automatically sets up odd/even page margins when gutters are enabled, includes page numbers starting at page 1 after front matter, and uses section breaks so new pages inherit the correct odd/even margins.</li>
        </ul>
        Transfer the SVG to your reMarkable device via a template installer tool: <a href="https://www.einkpads.com/products/template-installer-3?srsltid=AfmBOopwJoHFtn5R7SyFYEUARPLh2xGRlolOHLzbEUVteQBU2MMFFTDN" target="_blank">eInkPads Template Installer</a>, <a href="https://www.einkpads.com/pages/enhance-your-remarkable-tablet-with-einkpads" target="_blank">eInkPads Desktop App</a>, or <a href="https://freeremarkabletools.net" target="_blank">a free solution</a>
    </div>

    <hr class="page-separator" style="margin: 20px 0; border: none; border-top: 2px solid #ccc;">

    <h3 class="page-subtitle" style="text-align: center; color: #555; margin: 15px 0; font-weight: normal; font-style: italic;">
        Page as seen on your reMarkable
        <span id="pageTypeLabel" style="font-size: 14px; margin-left: 10px; color: #777;">(Showing Odd Page)</span>
        <button id="togglePageBtn" onclick="togglePage()" style="margin-left: 10px; padding: 6px 12px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">→</button>
    </h3>

    <div class="template-container">
        <div id="templatePage" class="template-page">
            <div id="borderOverlay" class="border-overlay"></div>
            <div id="marginLabelTop" class="margin-label-top"></div>
            <div id="marginLabelRight" class="margin-label-right"></div>
            <!-- Margin text labels -->
            <div id="centeringMarginTextTop" class="margin-text">Device Centering Margins</div>
            <div id="gutterMarginText" class="margin-text vertical">Gutter Margins</div>
            <div id="contentMarginTextTop" class="margin-text">Content Margins</div>
            <div id="contentMarginTextBottom" class="margin-text">Content Margins</div>
            <div id="contentMarginTextLeft" class="margin-text vertical">Content Margins</div>
            <div id="contentMarginTextRight" class="margin-text vertical">Content Margins</div>
            <div id="contentArea" class="content-area grid">
                <svg id="gridSvg" class="grid-svg"></svg>
                <div id="urlText" class="url-text">https://srives.github.io/reMarkable/</div>
                <div id="rulerLeft" class="ruler-left"></div>
                <div id="rulerBottom" class="ruler-bottom"></div>
                <div id="marginLines" class="margin-lines"></div>
                <div id="gutterMargin" class="gutter-margin"></div>
            </div>
        </div>
    </div>
    
    <script>
        const deviceTypeSelect = document.getElementById('deviceType');
        const scaleTypeSelect = document.getElementById('scaleType');
        const templateTypeSelect = document.getElementById('templateType');
        const pageSizeSelect = document.getElementById('pageSize');
        const bindingTypeSelect = document.getElementById('bindingType');
        const platformSelect = document.getElementById('platform');
        const marginTopSelect = document.getElementById('marginTop');
        const marginBottomSelect = document.getElementById('marginBottom');
        const marginLeftSelect = document.getElementById('marginLeft');
        const marginRightSelect = document.getElementById('marginRight');
        const marginColorSelect = document.getElementById('marginColor');
        const gridSizeSelect = document.getElementById('gridSize');
        const overlayGridSelect = document.getElementById('overlayGrid');
        const showRulersCheckbox = document.getElementById('showRulers');
        const showMarginDimensionsCheckbox = document.getElementById('showMarginDimensions');
        const gridSizeLabel = document.getElementById('gridSizeLabel');
        const overlayGridLabel = document.getElementById('overlayGridLabel');
        const contentArea = document.getElementById('contentArea');
        const borderOverlay = document.getElementById('borderOverlay');
        const marginLines = document.getElementById('marginLines');
        const templatePage = document.getElementById('templatePage');
        const urlText = document.getElementById('urlText');
        const marginRecommendation = document.getElementById('marginRecommendation');
        const recommendationText = document.getElementById('recommendationText');
        const rulerLeft = document.getElementById('rulerLeft');
        const rulerBottom = document.getElementById('rulerBottom');
        const gridSvg = document.getElementById('gridSvg');
        const usableArea = document.getElementById('usableArea');
        const marginLabelTop = document.getElementById('marginLabelTop');
        const marginLabelRight = document.getElementById('marginLabelRight');
        const debugInfo = document.getElementById('debugInfo');
        const pdfPageCount = document.getElementById('pdfPageCount');
        const useGutterMarginsCheckbox = document.getElementById('useGutterMargins');
        const gutterLeftSelect = document.getElementById('gutterLeft');
        const gutterRightSelect = document.getElementById('gutterRight');
        const gutterColorSelect = document.getElementById('gutterColor');
        const gutterMargin = document.getElementById('gutterMargin');
        const pageTypeLabel = document.getElementById('pageTypeLabel');
        const showMarginTextsCheckbox = document.getElementById('showMarginTexts');
        const centeringMarginTextTop = document.getElementById('centeringMarginTextTop');
        const gutterMarginText = document.getElementById('gutterMarginText');
        const contentMarginTextTop = document.getElementById('contentMarginTextTop');
        const contentMarginTextBottom = document.getElementById('contentMarginTextBottom');
        const contentMarginTextLeft = document.getElementById('contentMarginTextLeft');
        const contentMarginTextRight = document.getElementById('contentMarginTextRight');
        const centeringMarginColorSelect = document.getElementById('centeringMarginColor');
        const centeringMarginColorLabel = document.getElementById('centeringMarginColorLabel');

        let rulerFontSize = 10; // Default ruler text size
        let isOddPage = true; // Track whether we're showing odd or even page

        // Cookie management functions
        function setCookie(name, value, days = 365) {
            const expires = new Date();
            expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
            document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/`;
        }

        function getCookie(name) {
            const nameEQ = name + "=";
            const ca = document.cookie.split(';');
            for (let i = 0; i < ca.length; i++) {
                let c = ca[i];
                while (c.charAt(0) === ' ') c = c.substring(1, c.length);
                if (c.indexOf(nameEQ) === 0) return decodeURIComponent(c.substring(nameEQ.length, c.length));
            }
            return null;
        }

        function saveSettings() {
            setCookie('rm_deviceType', deviceTypeSelect.value);
            setCookie('rm_scaleType', scaleTypeSelect.value);
            setCookie('rm_pageSize', pageSizeSelect.value);
            setCookie('rm_templateType', templateTypeSelect.value);
            setCookie('rm_gridSize', gridSizeSelect.value);
            setCookie('rm_overlayGrid', overlayGridSelect.value);
            setCookie('rm_bindingType', bindingTypeSelect.value);
            setCookie('rm_platform', platformSelect.value);
            setCookie('rm_marginTop', marginTopSelect.value);
            setCookie('rm_marginBottom', marginBottomSelect.value);
            setCookie('rm_marginLeft', marginLeftSelect.value);
            setCookie('rm_marginRight', marginRightSelect.value);
            setCookie('rm_marginColor', marginColorSelect.value);
            setCookie('rm_useGutterMargins', useGutterMarginsCheckbox.checked);
            setCookie('rm_gutterLeft', gutterLeftSelect.value);
            setCookie('rm_gutterRight', gutterRightSelect.value);
            setCookie('rm_gutterColor', gutterColorSelect.value);
            setCookie('rm_centeringMarginColor', centeringMarginColorSelect.value);
            setCookie('rm_showRulers', showRulersCheckbox.checked);
            setCookie('rm_showMarginDimensions', showMarginDimensionsCheckbox.checked);
            setCookie('rm_showMarginTexts', showMarginTextsCheckbox.checked);
            setCookie('rm_rulerFontSize', rulerFontSize);
            setCookie('rm_pdfPageCount', pdfPageCount.value);
        }

        function loadSettings() {
            const savedDevice = getCookie('rm_deviceType');
            if (savedDevice && deviceTypeSelect.querySelector(`option[value="${savedDevice}"]`)) {
                deviceTypeSelect.value = savedDevice;
            }

            const savedScale = getCookie('rm_scaleType');
            if (savedScale) scaleTypeSelect.value = savedScale;

            const savedPageSize = getCookie('rm_pageSize');
            if (savedPageSize) {
                // Will be set after updatePageSizes() populates the dropdown
                setTimeout(() => {
                    if (pageSizeSelect.querySelector(`option[value="${savedPageSize}"]`)) {
                        pageSizeSelect.value = savedPageSize;
                    }
                }, 0);
            }

            const savedTemplateType = getCookie('rm_templateType');
            if (savedTemplateType) templateTypeSelect.value = savedTemplateType;

            const savedGridSize = getCookie('rm_gridSize');
            if (savedGridSize) gridSizeSelect.value = savedGridSize;

            const savedOverlayGrid = getCookie('rm_overlayGrid');
            if (savedOverlayGrid) overlayGridSelect.value = savedOverlayGrid;

            const savedBindingType = getCookie('rm_bindingType');
            if (savedBindingType) bindingTypeSelect.value = savedBindingType;

            const savedPlatform = getCookie('rm_platform');
            if (savedPlatform) platformSelect.value = savedPlatform;

            const savedMarginColor = getCookie('rm_marginColor');
            if (savedMarginColor) marginColorSelect.value = savedMarginColor;

            const savedUseGutterMargins = getCookie('rm_useGutterMargins');
            if (savedUseGutterMargins !== null) useGutterMarginsCheckbox.checked = savedUseGutterMargins === 'true';

            const savedGutterColor = getCookie('rm_gutterColor');
            if (savedGutterColor) gutterColorSelect.value = savedGutterColor;

            const savedCenteringMarginColor = getCookie('rm_centeringMarginColor');
            if (savedCenteringMarginColor) centeringMarginColorSelect.value = savedCenteringMarginColor;

            const savedShowRulers = getCookie('rm_showRulers');
            if (savedShowRulers !== null) showRulersCheckbox.checked = savedShowRulers === 'true';

            const savedShowMarginDimensions = getCookie('rm_showMarginDimensions');
            if (savedShowMarginDimensions !== null) showMarginDimensionsCheckbox.checked = savedShowMarginDimensions === 'true';

            const savedShowMarginTexts = getCookie('rm_showMarginTexts');
            if (savedShowMarginTexts !== null) showMarginTextsCheckbox.checked = savedShowMarginTexts === 'true';

            const savedRulerFontSize = getCookie('rm_rulerFontSize');
            if (savedRulerFontSize) {
                rulerFontSize = parseInt(savedRulerFontSize);
                updateRulerSizeLabel();
            }

            const savedPdfPageCount = getCookie('rm_pdfPageCount');
            if (savedPdfPageCount) pdfPageCount.value = savedPdfPageCount;

            // Margins will be loaded after dropdowns are populated
            setTimeout(() => {
                const savedMarginTop = getCookie('rm_marginTop');
                if (savedMarginTop && marginTopSelect.querySelector(`option[value="${savedMarginTop}"]`)) {
                    marginTopSelect.value = savedMarginTop;
                }

                const savedMarginBottom = getCookie('rm_marginBottom');
                if (savedMarginBottom && marginBottomSelect.querySelector(`option[value="${savedMarginBottom}"]`)) {
                    marginBottomSelect.value = savedMarginBottom;
                }

                const savedMarginLeft = getCookie('rm_marginLeft');
                if (savedMarginLeft && marginLeftSelect.querySelector(`option[value="${savedMarginLeft}"]`)) {
                    marginLeftSelect.value = savedMarginLeft;
                }

                const savedMarginRight = getCookie('rm_marginRight');
                if (savedMarginRight && marginRightSelect.querySelector(`option[value="${savedMarginRight}"]`)) {
                    marginRightSelect.value = savedMarginRight;
                }

                const savedGutterLeft = getCookie('rm_gutterLeft');
                if (savedGutterLeft && gutterLeftSelect.querySelector(`option[value="${savedGutterLeft}"]`)) {
                    gutterLeftSelect.value = savedGutterLeft;
                }

                const savedGutterRight = getCookie('rm_gutterRight');
                if (savedGutterRight && gutterRightSelect.querySelector(`option[value="${savedGutterRight}"]`)) {
                    gutterRightSelect.value = savedGutterRight;
                }

                updateTemplate();
            }, 100);
        }

        const devices = {
            rm2: {
                name: 'reMarkable 1/2',
                width: 1404,
                height: 1872,
                dpi: 226,
                unscaledDpi: 226,
                unscaledWidth: 6.25,
                unscaledHeight: 8.25,
                sizes: [
                    { value: '1404,1872', label: 'Full reMarkable 1/2 (6.21" × 8.28")' },
                    { value: '961,1553', label: 'Pocket Book (Mass Market) (4.25" × 6.87")' },
                    { value: '961,1582', label: '1970s Pocket Book (4.25" × 7")' },
                    { value: '1130,1808', label: 'Fiction Portrait (5" × 8")' },
                    { value: '1130,1582', label: 'YA Fiction (5" × 7")' },
                    { value: '1186,1808', label: 'Fiction Portrait (5.25" × 8")' },
                    { value: '1317,1869', label: 'A5 Portrait (5.83" × 8.27")' },
                    { value: '933,1317', label: 'A6 Portrait (4.13" × 5.83")' },
                    { value: '1146,1763', label: 'UK B-Format Portrait (5.07" × 7.8")' },
                    { value: '1388,2081', label: 'Royal Portrait (6.14" × 9.21")' },
                    { value: '1130,1130', label: 'Square (5" × 5")' },
                    { value: '1356,1356', label: 'Square (6" × 6")' }
                ]
            },
            rmpro: {
                name: 'reMarkable Pro',
                width: 1620,
                height: 2160,
                dpi: 229,
                unscaledDpi: 200,
                unscaledWidth: 7.8,
                unscaledHeight: 10.8,
                sizes: [
                    { value: '1620,2160', label: 'Full reMarkable Pro (7.07" × 9.43")' },
                    { value: '973,1573', label: 'Pocket Book (Mass Market) (4.25" × 6.87")' },
                    { value: '973,1603', label: '1970s Pocket Book (4.25" × 7")' },
                    { value: '1145,1832', label: 'Fiction Portrait (5" × 8")' },
                    { value: '1145,1603', label: 'YA Fiction (5" × 7")' },
                    { value: '1202,1832', label: 'Fiction Portrait (5.25" × 8")' },
                    { value: '1260,1947', label: 'Digest Portrait (5.5" × 8.5")' },
                    { value: '1374,2061', label: 'US Trade Portrait (6" × 9")' },
                    { value: '1335,1894', label: 'A5 Portrait (5.83" × 8.27")' },
                    { value: '946,1335', label: 'A6 Portrait (4.13" × 5.83")' },
                    { value: '1161,1786', label: 'UK B-Format Portrait (5.07" × 7.8")' },
                    { value: '1406,2109', label: 'Royal Portrait (6.14" × 9.21")' },
                    { value: '1145,1145', label: 'Square (5" × 5")' },
                    { value: '1374,1374', label: 'Square (6" × 6")' },
                    { value: '1603,1603', label: 'Square (7" × 7")' }
                ]
            },
            paperpromove: {
                name: 'Paper Pro Move',
                width: 954,
                height: 1696,
                dpi: 264,
                unscaledDpi: 220,
                unscaledWidth: 4.24,
                unscaledHeight: 7.7,
                sizes: [
                    { value: '953,1695', label: 'Full Paper Pro Move (3.61" × 6.42")' },
                    { value: '792,1122', label: 'Compact (3" × 4.25")' },
                    { value: '792,1320', label: 'Medium (3" × 5")' },
                    { value: '792,1584', label: 'Tall (3" × 6")' }
                ]
            }
        };
        
        const defaultMarginsInches = {
            '1404,1872': { top: 0.6, bottom: 0.65, left: 0.6, right: 0.6 },
            '1620,2160': { top: 0.6, bottom: 0.65, left: 0.65, right: 0.6 },
            '961,1553': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.4 },
            '973,1573': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.4 },
            '961,1582': { top: 0.4, bottom: 0.5, left: 0.4, right: 0.4 },
            '973,1603': { top: 0.4, bottom: 0.5, left: 0.4, right: 0.4 },
            '1122,1814': { top: 0.35, bottom: 0.4, left: 0.35, right: 0.35 },
            '1130,1808': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1130,1582': { top: 0.5, bottom: 0.6, left: 0.5, right: 0.5 },
            '1145,1832': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1145,1603': { top: 0.5, bottom: 0.6, left: 0.5, right: 0.5 },
            '1186,1808': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1202,1832': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1260,1947': { top: 0.5, bottom: 0.55, left: 0.5, right: 0.45 },
            '1374,2061': { top: 0.55, bottom: 0.6, left: 0.55, right: 0.5 },
            '1317,1869': { top: 0.55, bottom: 0.6, left: 0.5, right: 0.5 },
            '1335,1894': { top: 0.55, bottom: 0.6, left: 0.5, right: 0.5 },
            '933,1317': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.35 },
            '946,1335': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.35 },
            '1146,1763': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1161,1786': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.4 },
            '1388,2081': { top: 0.55, bottom: 0.6, left: 0.55, right: 0.5 },
            '1406,2109': { top: 0.55, bottom: 0.6, left: 0.55, right: 0.5 },
            '1130,1130': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.4 },
            '1145,1145': { top: 0.4, bottom: 0.45, left: 0.4, right: 0.4 },
            '1356,1356': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.45 },
            '1374,1374': { top: 0.45, bottom: 0.5, left: 0.45, right: 0.45 },
            '1603,1603': { top: 0.5, bottom: 0.55, left: 0.5, right: 0.5 },
            '953,1695': { top: 0.3, bottom: 0.35, left: 0.3, right: 0.3 },
            '792,1122': { top: 0.25, bottom: 0.3, left: 0.25, right: 0.25 },
            '792,1320': { top: 0.25, bottom: 0.3, left: 0.25, right: 0.25 },
            '792,1584': { top: 0.3, bottom: 0.35, left: 0.25, right: 0.25 }
        };
        
        const marginRecommendations = {
            binding: {
                perfect: {
                    name: "Perfect Binding",
                    gutterInches: 0.375, // Minimum gutter for perfect binding
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (!margins) return "Not found";

                        // Equalize left/right margins
                        const leftRight = Math.min(margins.left, margins.right);
                        const gutterDiff = Math.abs(margins.left - margins.right);
                        const gutterMin = Math.max(gutterDiff, 0.625);
                        const gutterMax = gutterMin + 0.125;
                        let gutterText = gutterDiff > 0 ? ` Recommended gutter: ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".` : '';
                        return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". <strong>Gutter:</strong> ${gutterMin}\"-${gutterMax}\" (increases with page count).${gutterText} Minimum 0.375\" gutter, pages glued into spine.`;
                    }
                },
                saddle: {
                    name: "Saddle Stitch",
                    gutterInches: 0.0, // Saddle stitch doesn't need additional gutter
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (!margins) return "Not found";

                        // Equalize left/right margins
                        const leftRight = Math.min(margins.left, margins.right);
                        const gutterDiff = Math.abs(margins.left - margins.right);
                        let gutterText = '';
                        if (gutterDiff > 0) {
                            gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\" (optional, pages lie flat).`;
                        }

                        // Saddle stitch can use smaller, more equal margins (pages lie flat)
                        const minMargin = 0.25;
                        const avgMargin = Math.max(minMargin, Math.min(margins.top, margins.bottom, leftRight) - 0.125);
                        return `For this size: All margins ${avgMargin.toFixed(2)}\"-${(avgMargin + 0.125).toFixed(2)}\" (more equal). Pages lie flat when folded.${gutterText} Best for 8-60 pages. Requires page count in multiples of 4.`;
                    }
                },
                spiral: {
                    name: "Spiral/Coil Binding",
                    gutterInches: 0.625, // Spiral needs space for punch holes
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (!margins) return "Not found";

                        // Equalize left/right margins
                        const leftRight = Math.min(margins.left, margins.right);
                        const gutterDiff = Math.abs(margins.left - margins.right);
                        const gutter = Math.max(gutterDiff, 0.625);
                        let gutterText = gutterDiff > 0 ? ` Recommended gutter: ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".` : '';
                        return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". <strong>Gutter:</strong> ${gutter}\" minimum (for punch holes, drills 1/4\" in).${gutterText} Pages lie completely flat and rotate 360°. Holes punch 3/16\"-1/4\" into gutter.`;
                    }
                },
                wireo: {
                    name: "Wire-O Binding",
                    gutterInches: 0.75, // Wire-O needs space for square holes
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (!margins) return "Not found";

                        // Equalize left/right margins
                        const leftRight = Math.min(margins.left, margins.right);
                        const gutterDiff = Math.abs(margins.left - margins.right);
                        const gutter = Math.max(gutterDiff, 0.75);
                        let gutterText = gutterDiff > 0 ? ` Recommended gutter: ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".` : '';
                        return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". <strong>Gutter:</strong> ${gutter}\"-0.875\" minimum (for wire loops, punches 1/4\" in).${gutterText} Square holes. Pages lay flat and flip 360°.`;
                    }
                },
                case: {
                    name: "Case Binding (Hardcover)",
                    gutterInches: 0.75, // Case binding needs larger gutter (0.75"-1.0")
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (!margins) return "Not found";

                        // Equalize left/right margins
                        const leftRight = Math.min(margins.left, margins.right);
                        const gutterDiff = Math.abs(margins.left - margins.right);
                        const gutterMin = Math.max(gutterDiff, 0.75);
                        const gutterMax = Math.max(gutterMin, 1.0);
                        const topMin = Math.max(margins.top, 0.625);
                        const bottomMin = Math.max(margins.bottom, 0.75);
                        let gutterText = gutterDiff > 0 ? ` Recommended gutter: ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".` : '';
                        return `For this size: Top ${topMin}\", Bottom ${bottomMin}\", Left/Right ${leftRight}\". <strong>Gutter:</strong> ${gutterMin}\"-${gutterMax}\" minimum (rigid spine).${gutterText} More generous margins for premium feel. 6mm margin each side of gutter.`;
                    }
                }
            },
            platform: {
                general: {
                    name: "General Publishing",
                    gutterInches: null, // No specific gutter, fall back to binding type
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = '';
                            if (gutterDiff > 0) {
                                gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\" (please validate).`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\".${gutterText} Standard industry practice with bottom margin typically largest for page numbers.`;
                        }
                        return "Standard industry practice: Inner 0.625\"-0.75\", Top 0.5\"-0.625\", Bottom 0.625\"-0.75\", Outer 0.5\"-0.625\". Bottom margin typically largest.";
                    }
                },
                kdp: {
                    name: "Amazon KDP",
                    gutterInches: 0.125, // KDP includes gutter in inside margin, use moderate value
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = ` <strong>Gutter:</strong> KDP includes gutter in the inside margin - use 0.5\" total inside for <24 pages, 0.625\" for 24-150 pages, 0.75\" for 151-300 pages, 0.875\" for 301-500 pages, 1.0\" for 501-800 pages.`;
                            if (gutterDiff > 0) {
                                gutterText += ` Recommended gutter for this page: ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". KDP requires minimum 0.375\" all sides (safe zone).${gutterText}`;
                        }
                        return "Minimum 0.375\" safe zone all sides. Gutter included in inside margin: 0.5\" total for thin books, 0.75\"-1\" for 200+ pages.";
                    }
                },
                ingram: {
                    name: "IngramSpark",
                    gutterInches: 0.125, // IngramSpark recommends 0.125" additional gutter
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            const recommendedGutter = gutterDiff > 0 ? gutterDiff : 0.125;
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". IngramSpark requires minimum 0.5\" all sides, with text at least 0.25\" from trim line. <strong>Gutter:</strong> Add ${recommendedGutter.toFixed(3).replace(/\.?0+$/, '')}\" white strip on bind side for perfect bound/hardcover books. Total inside: ${(leftRight + recommendedGutter).toFixed(3).replace(/\.?0+$/, '')}\" minimum.`;
                        }
                        return "Minimum 0.5\" all sides required. Text must be 0.25\" from trim. Gutter: 0.125\" additional on bind side for perfect/hardcover.";
                    }
                },
                lulu: {
                    name: "Lulu",
                    gutterInches: 0.25, // Lulu recommends 0.2"-0.3", using middle value
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            const recommendedGutter = gutterDiff > 0 ? gutterDiff : 0.25;
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\". Lulu requires 0.5\" safety margin all sides. <strong>Gutter:</strong> ${recommendedGutter.toFixed(3).replace(/\.?0+$/, '')}\" for most bindings, 0.375\" (9mm) for coil-bound books (coils bite ~0.312\" into spine edge). Total inside: ${(leftRight + recommendedGutter).toFixed(3).replace(/\.?0+$/, '')}\".`;
                        }
                        return "Minimum 0.5\" safety margin all sides. Gutter: 0.2\"-0.3\" standard, 0.375\" for coil-bound. Total inside: 0.7\"-0.875\".";
                    }
                },
                bn: {
                    name: "Barnes & Noble Press",
                    gutterInches: 0.125, // B&N Press uses standard gutter
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = '';
                            if (gutterDiff > 0) {
                                gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\".${gutterText} B&N Press standard is 0.5\" three sides, 0.75\" inside margin.`;
                        }
                        return "Standard: 0.5\" three sides, 0.75\" inside margin. Adjust gutter for thicker books.";
                    }
                },
                d2d: {
                    name: "Draft2Digital",
                    gutterInches: 0.125, // D2D follows KDP guidelines
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = '';
                            if (gutterDiff > 0) {
                                gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\".${gutterText} Draft2Digital uses automated layout but these margins work well with their system.`;
                        }
                        return "Works with multiple print partners. Safe margins: Inside 0.625\", Outside 0.5\", Top 0.5\", Bottom 0.625\". Follows KDP guidelines generally.";
                    }
                },
                blurb: {
                    name: "Blurb",
                    gutterInches: 0.125, // Blurb uses standard gutter
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = '';
                            if (gutterDiff > 0) {
                                gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\".${gutterText} Blurb requires critical content 0.25\" from trim, with 0.5\" recommended for safety.`;
                        }
                        return "Critical content must be 0.25\" from trim. Standard: 0.5\" minimum all sides. Trade books: Inside 0.625\", Outside 0.5\", Top 0.5\", Bottom 0.625\".";
                    }
                },
                bookbaby: {
                    name: "BookBaby",
                    gutterInches: 0.125, // BookBaby uses standard gutter
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            let gutterText = '';
                            if (gutterDiff > 0) {
                                gutterText = ` <strong>Gutter:</strong> ${gutterDiff.toFixed(3).replace(/\.?0+$/, '')}\".`;
                            }
                            return `For this size: Top ${margins.top}\", Bottom ${margins.bottom}\", Left/Right ${leftRight}\".${gutterText} BookBaby recommends generous margins (0.875\" left/right minimum) for professional appearance.`;
                        }
                        return "Minimum 0.5\" all sides recommended. Professional standard: Inside 0.75\"-0.875\", Outside 0.5\", Top 0.625\", Bottom 0.75\".";
                    }
                },
                canva: {
                    name: "Canva Print",
                    gutterInches: 0.3, // Canva recommends 0.3" for smyth sewn, 0.6" for perfect bound
                    getDesc: function(pageSize) {
                        const margins = defaultMarginsInches[pageSize];
                        if (margins) {
                            // Canva requires minimum 0.25" from trim, with gutter depending on binding type
                            const leftRight = Math.min(margins.left, margins.right);
                            const gutterDiff = Math.abs(margins.left - margins.right);
                            const recommendedGutter = gutterDiff > 0 ? gutterDiff : 0.3;
                            const minMargin = Math.max(margins.top, margins.bottom, leftRight, 0.25);
                            return `For this size: Gutter ${recommendedGutter.toFixed(3).replace(/\.?0+$/, '')}\" (0.3\" smyth sewn, 0.6\" perfect bound), Other margins ${minMargin}\". Canva adds 0.125\" bleed automatically. Keep all text/elements minimum 0.25\" from trim lines.`;
                        }
                        return "Minimum 0.25\" all sides from trim. Smyth sewn: 0.3\" gutter, Perfect bound: 0.6\" gutter. Canva adds 0.125\" (3mm) bleed on all sides automatically.";
                    }
                }
            }
        };
        
        function updateRecommendation() {
            const binding = marginRecommendations.binding[bindingTypeSelect.value];
            const platform = marginRecommendations.platform[platformSelect.value];
            const currentPageSize = pageSizeSelect.value;

            const bindingDesc = typeof binding.getDesc === 'function'
                ? binding.getDesc(currentPageSize)
                : binding.desc;

            const platformDesc = typeof platform.getDesc === 'function'
                ? platform.getDesc(currentPageSize)
                : platform.desc;

            recommendationText.innerHTML = `
                <div style="margin-bottom: 8px;"><strong>${binding.name}:</strong> ${bindingDesc}</div>
                <div><strong>${platform.name}:</strong> ${platformDesc}</div>
            `;
            marginRecommendation.style.display = 'block';

            // Also update gutter values based on recommendations
            updateRecommendedGutters();
        }

        function updateRecommendedGutters() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;
            const gutterInches = getRecommendedGutter();
            const gutterPx = Math.round(gutterInches * dpi * 100) / 100;

            // Update gutter values for both odd and even pages
            gutterLeftSelect.value = gutterPx;
            gutterRightSelect.value = gutterPx;
        }
        
        function getRecommendedGutter() {
            const platform = marginRecommendations.platform[platformSelect.value];
            const binding = marginRecommendations.binding[bindingTypeSelect.value];

            // Try platform-specific gutter first
            if (platform && platform.gutterInches !== null && platform.gutterInches !== undefined) {
                return platform.gutterInches;
            }

            // Fall back to binding type gutter
            if (binding && binding.gutterInches !== null && binding.gutterInches !== undefined) {
                return binding.gutterInches;
            }

            // Default fallback
            return 0.125;
        }

        function applyRecommendedMargins() {
            applyDefaultMargins();

            // Also apply recommended gutter margins
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;
            const gutterInches = getRecommendedGutter();
            const gutterPx = Math.round(gutterInches * dpi * 100) / 100;

            // Set gutter values for both odd and even pages
            gutterLeftSelect.value = gutterPx;
            gutterRightSelect.value = gutterPx;

            updateTemplate();
        }

        window.applyRecommendedMargins = applyRecommendedMargins;

        function resetMargins() {
            marginTopSelect.value = 0;
            marginBottomSelect.value = 0;
            marginLeftSelect.value = 0;
            marginRightSelect.value = 0;
            updateTemplate();
        }

        function togglePage() {
            isOddPage = !isOddPage;
            pageTypeLabel.textContent = isOddPage ? '(Showing Odd Page)' : '(Showing Even Page)';
            updateTemplate();
        }

        window.togglePage = togglePage;

        function updateGutterDropdowns() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;

            const currentLeft = gutterLeftSelect.value;
            const currentRight = gutterRightSelect.value;

            const gutterSelects = [gutterLeftSelect, gutterRightSelect];

            gutterSelects.forEach(select => {
                select.innerHTML = '';

                // Add option for no gutter
                const noneOption = document.createElement('option');
                noneOption.value = 0;
                noneOption.textContent = '0"';
                select.appendChild(noneOption);

                // Use 0.025" increments to support values like 0.375", 0.625", 0.875"
                for (let inches = 0.025; inches <= 1.5; inches += 0.025) {
                    const pixels = Math.round(inches * dpi * 100) / 100;
                    const option = document.createElement('option');
                    option.value = pixels;
                    // Format to 3 decimal places, remove trailing zeros
                    option.textContent = inches.toFixed(3).replace(/\.?0+$/, '') + '"';
                    select.appendChild(option);
                }
            });

            // Set default gutter values (0.125" = ~28px for most devices)
            const defaultGutterPx = Math.round(0.125 * dpi * 100) / 100;
            gutterLeftSelect.value = currentLeft || defaultGutterPx;
            gutterRightSelect.value = currentRight || defaultGutterPx;
        }

        function increaseRulerSize() {
            if (rulerFontSize < 20) {
                rulerFontSize += 1;
                updateRulerSizeLabel();
                updateTemplate();
                saveSettings();
            }
        }

        function decreaseRulerSize() {
            if (rulerFontSize > 4) {
                rulerFontSize -= 1;
                updateRulerSizeLabel();
                updateTemplate();
                saveSettings();
            }
        }

        function updateRulerSizeLabel() {
            const label = document.getElementById('rulerSizeLabel');
            if (label) {
                label.textContent = `Text Size ${rulerFontSize}`;
            }
        }

        window.resetMargins = resetMargins;
        window.increaseRulerSize = increaseRulerSize;
        window.decreaseRulerSize = decreaseRulerSize;

        function applyDefaultMargins() {
            const device = devices[deviceTypeSelect.value];
            const pageSize = pageSizeSelect.value;
            const marginsInches = defaultMarginsInches[pageSize];
            const isScaled = scaleTypeSelect.value === 'yes';

            // Use appropriate DPI based on scaling mode (matches margin dropdown calculations)
            const dpi = isScaled ? device.dpi : device.unscaledDpi;

            if (marginsInches) {
                // Equalize left/right margins to the smallest value
                const leftRightInches = Math.min(marginsInches.left, marginsInches.right);

                const topPx = Math.round(marginsInches.top * dpi * 100) / 100;
                const bottomPx = Math.round(marginsInches.bottom * dpi * 100) / 100;
                const leftPx = Math.round(leftRightInches * dpi * 100) / 100;
                const rightPx = Math.round(leftRightInches * dpi * 100) / 100;

                marginTopSelect.value = topPx;
                marginBottomSelect.value = bottomPx;
                marginLeftSelect.value = leftPx;
                marginRightSelect.value = rightPx;
            }
        }
        
        function updateMarginDropdowns() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;

            const currentTop = marginTopSelect.value;
            const currentBottom = marginBottomSelect.value;
            const currentLeft = marginLeftSelect.value;
            const currentRight = marginRightSelect.value;

            const marginSelects = [marginTopSelect, marginBottomSelect, marginLeftSelect, marginRightSelect];

            marginSelects.forEach(select => {
                select.innerHTML = '';

                // Use 0.025" increments to match gutter dropdown granularity
                for (let inches = 0; inches <= 1.5; inches += 0.025) {
                    const pixels = Math.round(inches * dpi * 100) / 100;
                    const option = document.createElement('option');
                    option.value = pixels;
                    // Format to 3 decimal places, remove trailing zeros
                    option.textContent = inches.toFixed(3).replace(/\.?0+$/, '') + '"';
                    select.appendChild(option);
                }
            });

            marginTopSelect.value = currentTop;
            marginBottomSelect.value = currentBottom;
            marginLeftSelect.value = currentLeft;
            marginRightSelect.value = currentRight;

            updateGutterDropdowns();
        }
        
        function updateCenteringColorVisibility() {
            const isScaled = scaleTypeSelect.value === 'yes';
            if (isScaled) {
                centeringMarginColorLabel.style.display = 'inline';
                centeringMarginColorSelect.style.display = 'inline';
            } else {
                centeringMarginColorLabel.style.display = 'none';
                centeringMarginColorSelect.style.display = 'none';
            }
        }

        function updatePageSizes() {
            const device = devices[deviceTypeSelect.value];
            const currentValue = pageSizeSelect.value;
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;

            templatePage.style.width = device.width + 'px';
            templatePage.style.height = device.height + 'px';

            updatePrintPageSize(device.width, device.height);
            updateMarginDropdowns();

            pageSizeSelect.innerHTML = '';
            device.sizes.forEach((size, index) => {
                const [width, height] = size.value.split(',').map(Number);
                const option = document.createElement('option');
                option.value = size.value;

                let fits;
                if (width > height) {
                    fits = (width <= device.height && height <= device.width);
                } else {
                    fits = (width <= device.width && height <= device.height);
                }

                if (!fits) {
                    option.textContent = size.label + ' (Too Large)';
                    option.disabled = true;
                    option.style.color = '#999';
                } else {
                    // Only update the first (Full) item when scaling is off
                    if (!isScaled && index === 0) {
                        const baseName = size.label.replace(/\([\d\.]+"\s*×\s*[\d\.]+"\)/, '').trim();
                        option.textContent = `${baseName} (${device.unscaledWidth}" × ${device.unscaledHeight}")`;
                    } else {
                        option.textContent = size.label;
                    }
                }

                pageSizeSelect.appendChild(option);
            });

            const sameIndex = device.sizes.findIndex(s => s.value === currentValue);
            if (sameIndex >= 0) {
                const [width, height] = currentValue.split(',').map(Number);
                let fits;
                if (width > height) {
                    fits = (width <= device.height && height <= device.width);
                } else {
                    fits = (width <= device.width && height <= device.height);
                }
                if (fits) {
                    pageSizeSelect.selectedIndex = sameIndex;
                } else {
                    pageSizeSelect.selectedIndex = 0;
                }
            } else {
                pageSizeSelect.selectedIndex = 0;
            }

            // Set default margin color based on device type
            if (deviceTypeSelect.value === 'rm2') {
                marginColorSelect.value = 'rgba(60, 60, 60, 0.3)'; // Dark Gray for reMarkable 1/2
            } else {
                marginColorSelect.value = 'rgba(255, 182, 193, 0.3)'; // Light Pink for other devices
            }

            applyDefaultMargins();
            updateCenteringColorVisibility();
            updateTemplate();
        }

        function updatePrintPageSize(width, height) {
            const existingStyle = document.getElementById('dynamic-print-style');
            if (existingStyle) {
                existingStyle.remove();
            }
            
            const style = document.createElement('style');
            style.id = 'dynamic-print-style';
            style.textContent = `
                @media print {
                    @page {
                        size: ${width}px ${height}px;
                        margin: 0;
                    }
                    body {
                        width: ${width}px;
                        height: ${height}px;
                    }
                    .template-page {
                        width: ${width}px !important;
                        height: ${height}px !important;
                    }
                }
            `;
            document.head.appendChild(style);
        }
        
        function applyGutterToPage(pageElement, pageNumber) {
            if (!useGutterMarginsCheckbox.checked) {
                return;
            }

            const gutterLeft = parseFloat(gutterLeftSelect.value);
            const gutterRight = parseFloat(gutterRightSelect.value);
            const gutterColor = gutterColorSelect.value;

            const gutterMarginEl = pageElement.querySelector('.gutter-margin');
            const marginLinesEl = pageElement.querySelector('.margin-lines');

            if (!gutterMarginEl || !marginLinesEl) return;

            const isPageOdd = (pageNumber % 2 === 1);
            const gutterWidth = isPageOdd ? gutterLeft : gutterRight;

            if (gutterWidth > 0) {
                gutterMarginEl.style.display = 'block';
                gutterMarginEl.style.width = gutterWidth + 'px';
                gutterMarginEl.style.backgroundColor = gutterColor;

                if (isPageOdd) {
                    // Odd pages: gutter on left side
                    gutterMarginEl.style.left = '0px';
                    gutterMarginEl.style.right = 'auto';
                    marginLinesEl.style.left = gutterWidth + 'px';
                    marginLinesEl.style.right = '0px';
                } else {
                    // Even pages: gutter on right side
                    gutterMarginEl.style.left = 'auto';
                    gutterMarginEl.style.right = '0px';
                    marginLinesEl.style.left = '0px';
                    marginLinesEl.style.right = gutterWidth + 'px';
                }
            } else {
                gutterMarginEl.style.display = 'none';
            }
        }

        function savePDF() {
            const selectedOption = pageSizeSelect.options[pageSizeSelect.selectedIndex];
            const pageLabel = selectedOption.textContent.trim();

            const filename = pageLabel
                .replace(/[^\w\s\-\(\)\.]/g, '')
                .replace(/\s+/g, '_')
                .replace(/_{2,}/g, '_');

            const originalTitle = document.title;
            document.title = filename;

            // Get number of pages to print
            const pageCount = parseInt(pdfPageCount.value);
            const clonedPages = [];

            // Apply gutter to the first page (page 1 = odd)
            if (useGutterMarginsCheckbox.checked) {
                applyGutterToPage(templatePage, 1);
            }

            // Clone the template page (pageCount - 1) times and insert after the original
            if (pageCount > 1) {
                const container = templatePage.parentElement;
                for (let i = 1; i < pageCount; i++) {
                    const clone = templatePage.cloneNode(true);
                    clone.id = 'templatePage_clone_' + i;

                    // Apply appropriate gutter for this page number (i+1 because page 1 is the original)
                    if (useGutterMarginsCheckbox.checked) {
                        applyGutterToPage(clone, i + 1);
                    }

                    container.appendChild(clone);
                    clonedPages.push(clone);
                }
            }

            window.print();

            setTimeout(() => {
                document.title = originalTitle;
                // Remove cloned pages after printing
                clonedPages.forEach(clone => clone.remove());
                // Restore the original page to current odd/even state
                updateTemplate();
            }, 1000);
        }

        function saveSVG() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const selectedOption = pageSizeSelect.options[pageSizeSelect.selectedIndex];
            const pageLabel = selectedOption.textContent.trim();

            const filename = pageLabel
                .replace(/[^\w\s\-\(\)\.]/g, '')
                .replace(/\s+/g, '_')
                .replace(/_{2,}/g, '_') + '.svg';

            // Get current page dimensions
            const pageWidth = device.width;
            const pageHeight = device.height;

            // Create SVG wrapper
            let svgContent = `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${pageWidth}" height="${pageHeight}" viewBox="0 0 ${pageWidth} ${pageHeight}">
    <rect width="${pageWidth}" height="${pageHeight}" fill="#f5f5f5"/>
`;

            // Get selected page size
            let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
            let offsetX = 0, offsetY = 0;
            if (isScaled) {
                offsetX = (device.width - selectedPageWidth) / 2;
                offsetY = (device.height - selectedPageHeight) / 2;
            }

            // Add gray centering margins if scaled
            if (offsetX > 0 || offsetY > 0) {
                const centeringColor = centeringMarginColorSelect.value;
                svgContent += `    <!-- Gray centering margins -->
    <rect x="0" y="0" width="${offsetX}" height="${pageHeight}" fill="${centeringColor}"/>
    <rect x="${pageWidth - offsetX}" y="0" width="${offsetX}" height="${pageHeight}" fill="${centeringColor}"/>
    <rect x="0" y="0" width="${pageWidth}" height="${offsetY}" fill="${centeringColor}"/>
    <rect x="0" y="${pageHeight - offsetY}" width="${pageWidth}" height="${offsetY}" fill="${centeringColor}"/>
`;
            }

            // Add white content area
            const contentX = isScaled ? offsetX : 0;
            const contentY = isScaled ? offsetY : 0;
            const contentWidth = isScaled ? selectedPageWidth : pageWidth;
            const contentHeight = isScaled ? selectedPageHeight : pageHeight;

            svgContent += `    <!-- Content area -->
    <rect x="${contentX}" y="${contentY}" width="${contentWidth}" height="${contentHeight}" fill="white"/>
`;

            // Add grid/lines from gridSvg
            const gridSvgContent = gridSvg.innerHTML;
            if (gridSvgContent) {
                svgContent += `    <!-- Grid -->
    <g transform="translate(${contentX}, ${contentY})">
${gridSvgContent}
    </g>
`;
            }

            // Calculate gutter for cumulative display
            let activeGutterLeft = 0;
            let activeGutterRight = 0;

            // Add gutter margins first (at the edge)
            if (useGutterMarginsCheckbox.checked) {
                const gutterLeft = parseFloat(gutterLeftSelect.value);
                const gutterRight = parseFloat(gutterRightSelect.value);
                const gutterColor = gutterColorSelect.value;
                const gutterWidth = isOddPage ? gutterLeft : gutterRight;

                if (gutterWidth > 0) {
                    svgContent += `    <!-- Gutter margin -->
`;
                    if (isOddPage) {
                        // Odd pages: gutter on left side
                        svgContent += `    <rect x="${contentX}" y="${contentY}" width="${gutterWidth}" height="${contentHeight}" fill="${gutterColor}"/>
`;
                        activeGutterLeft = gutterWidth;
                    } else {
                        // Even pages: gutter on right side
                        svgContent += `    <rect x="${contentX + contentWidth - gutterWidth}" y="${contentY}" width="${gutterWidth}" height="${contentHeight}" fill="${gutterColor}"/>
`;
                        activeGutterRight = gutterWidth;
                    }
                }
            }

            // Add filled margin areas (cumulative, after gutter)
            const marginTop = parseFloat(marginTopSelect.value);
            const marginBottom = parseFloat(marginBottomSelect.value);
            const marginLeft = parseFloat(marginLeftSelect.value);
            const marginRight = parseFloat(marginRightSelect.value);

            if (marginTop > 0 || marginBottom > 0 || marginLeft > 0 || marginRight > 0) {
                const marginColor = marginColorSelect.value;

                svgContent += `    <!-- Margin areas (cumulative with gutter) -->
`;
                // Adjust margin positions to account for gutter
                const marginContentX = contentX + activeGutterLeft;
                const marginContentWidth = contentWidth - activeGutterLeft - activeGutterRight;

                // Draw filled margin rectangles
                if (marginTop > 0) {
                    svgContent += `    <rect x="${marginContentX}" y="${contentY}" width="${marginContentWidth}" height="${marginTop}" fill="${marginColor}"/>
`;
                }
                if (marginBottom > 0) {
                    svgContent += `    <rect x="${marginContentX}" y="${contentY + contentHeight - marginBottom}" width="${marginContentWidth}" height="${marginBottom}" fill="${marginColor}"/>
`;
                }
                if (marginLeft > 0) {
                    svgContent += `    <rect x="${marginContentX}" y="${contentY}" width="${marginLeft}" height="${contentHeight}" fill="${marginColor}"/>
`;
                }
                if (marginRight > 0) {
                    svgContent += `    <rect x="${marginContentX + marginContentWidth - marginRight}" y="${contentY}" width="${marginRight}" height="${contentHeight}" fill="${marginColor}"/>
`;
                }
            }

            // Add rulers if enabled
            if (showRulersCheckbox.checked) {
                svgContent += `    <!-- Rulers -->
`;
                // Get full device dimensions for rulers
                let labelToUse = pageSizeSelect.options[0].text;
                const dimensionMatch = labelToUse.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
                let widthInInches, heightInInches;
                if (dimensionMatch) {
                    widthInInches = parseFloat(dimensionMatch[1]);
                    heightInInches = parseFloat(dimensionMatch[2]);
                } else {
                    widthInInches = pageWidth / device.dpi;
                    heightInInches = pageHeight / device.dpi;
                }

                const pixelsPerInchWidth = pageWidth / widthInInches;
                const pixelsPerInchHeight = pageHeight / heightInInches;

                // Left ruler (vertical)
                for (let i = 0.25; i <= heightInInches; i += 0.25) {
                    const y = i * pixelsPerInchHeight;
                    const text = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                    svgContent += `    <text x="4" y="${y}" font-family="Arial" font-size="${rulerFontSize}" fill="#666">${text}</text>
`;
                }

                // Bottom ruler (horizontal)
                for (let i = 0.25; i <= widthInInches; i += 0.25) {
                    const x = i * pixelsPerInchWidth;
                    const text = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                    svgContent += `    <text x="${x}" y="${pageHeight - 4}" font-family="Arial" font-size="${rulerFontSize}" fill="#666" text-anchor="middle">${text}</text>
`;
                }
            }

            // Add margin dimensions if enabled
            if (showMarginDimensionsCheckbox.checked) {
                // Calculate usable dimensions
                const selectedLabel = pageSizeSelect.options[pageSizeSelect.selectedIndex].text;
                const dimensionMatch = selectedLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
                let pageWidthInInches, pageHeightInInches;
                if (dimensionMatch) {
                    pageWidthInInches = parseFloat(dimensionMatch[1]);
                    pageHeightInInches = parseFloat(dimensionMatch[2]);
                } else {
                    const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                    const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                    pageWidthInInches = actualPageWidth / device.dpi;
                    pageHeightInInches = actualPageHeight / device.dpi;
                }

                const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                const pixelsPerInchWidth = actualPageWidth / pageWidthInInches;
                const pixelsPerInchHeight = actualPageHeight / pageHeightInInches;

                const marginTopIn = marginTop / pixelsPerInchHeight;
                const marginBottomIn = marginBottom / pixelsPerInchHeight;
                const marginLeftIn = marginLeft / pixelsPerInchWidth;
                const marginRightIn = marginRight / pixelsPerInchWidth;

                const usableWidthIn = pageWidthInInches - marginLeftIn - marginRightIn;
                const usableHeightIn = pageHeightInInches - marginTopIn - marginBottomIn;

                svgContent += `    <!-- Margin dimensions -->
`;
                // Top margin label - show usable width
                if (marginTop >= 20) {
                    const x = contentX + contentWidth / 2;
                    const y = contentY + marginTop / 2;
                    svgContent += `    <text x="${x}" y="${y}" font-family="Arial" font-size="${rulerFontSize}" font-weight="bold" fill="#aaa" text-anchor="middle" dominant-baseline="middle">${usableWidthIn.toFixed(2)}"</text>
`;
                }

                // Right margin label - show usable height (rotated)
                if (marginRight >= 20) {
                    const x = contentX + contentWidth - marginRight / 2;
                    const y = contentY + contentHeight / 2;
                    svgContent += `    <text x="${x}" y="${y}" font-family="Arial" font-size="${rulerFontSize}" font-weight="bold" fill="#aaa" text-anchor="middle" dominant-baseline="middle" transform="rotate(-90 ${x} ${y})">${usableHeightIn.toFixed(2)}"</text>
`;
                }
            }

            // Add URL text if there's enough top margin
            if (marginTop >= 15) {
                svgContent += `    <!-- URL text -->
    <text x="${contentX + contentWidth / 2}" y="${contentY + 5}" font-family="Arial" font-size="10" fill="#999" text-anchor="middle" dominant-baseline="hanging">https://srives.github.io/reMarkable/</text>
`;
            }

            // Add margin text labels if enabled
            if (showMarginTextsCheckbox.checked) {
                svgContent += `    <!-- Margin text labels -->
`;
                const marginContentX = contentX + activeGutterLeft;
                const marginContentWidth = contentWidth - activeGutterLeft - activeGutterRight;

                // 1. Device Centering Margins (top) - horizontal text
                if (offsetY > 20) {
                    svgContent += `    <text x="${pageWidth / 2}" y="${offsetY / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.3)" text-anchor="middle" dominant-baseline="middle">Device Centering Margins</text>
`;
                }

                // 2. Gutter Margins
                if (activeGutterLeft > 20) {
                    svgContent += `    <text x="${contentX + activeGutterLeft / 2}" y="${contentY + contentHeight / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle" writing-mode="tb" transform="rotate(180 ${contentX + activeGutterLeft / 2} ${contentY + contentHeight / 2})">Gutter Margins</text>
`;
                } else if (activeGutterRight > 20) {
                    svgContent += `    <text x="${contentX + contentWidth - activeGutterRight / 2}" y="${contentY + contentHeight / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle" writing-mode="tb" transform="rotate(180 ${contentX + contentWidth - activeGutterRight / 2} ${contentY + contentHeight / 2})">Gutter Margins</text>
`;
                }

                // 3. Content Margins - Top
                if (marginTop > 20) {
                    svgContent += `    <text x="${marginContentX + marginContentWidth / 2}" y="${contentY + marginTop / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle">Content Margins</text>
`;
                }

                // 4. Content Margins - Bottom
                if (marginBottom > 20) {
                    svgContent += `    <text x="${marginContentX + marginContentWidth / 2}" y="${contentY + contentHeight - marginBottom / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle">Content Margins</text>
`;
                }

                // 5. Content Margins - Left
                if (marginLeft > 20) {
                    svgContent += `    <text x="${marginContentX + marginLeft / 2}" y="${contentY + contentHeight / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle" writing-mode="tb" transform="rotate(180 ${marginContentX + marginLeft / 2} ${contentY + contentHeight / 2})">Content Margins</text>
`;
                }

                // 6. Content Margins - Right
                if (marginRight > 20) {
                    svgContent += `    <text x="${marginContentX + marginContentWidth - marginRight / 2}" y="${contentY + contentHeight / 2}" font-family="Arial" font-size="11" fill="rgba(100, 100, 100, 0.4)" text-anchor="middle" dominant-baseline="middle" writing-mode="tb" transform="rotate(180 ${marginContentX + marginContentWidth - marginRight / 2} ${contentY + contentHeight / 2})">Content Margins</text>
`;
                }
            }

            svgContent += `</svg>`;

            // Download SVG
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        function savePNG() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const selectedOption = pageSizeSelect.options[pageSizeSelect.selectedIndex];
            const pageLabel = selectedOption.textContent.trim();

            const filename = pageLabel
                .replace(/[^\w\s\-\(\)\.]/g, '')
                .replace(/\s+/g, '_')
                .replace(/_{2,}/g, '_') + '.png';

            // Get current page dimensions
            const pageWidth = device.width;
            const pageHeight = device.height;

            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = pageWidth;
            canvas.height = pageHeight;
            const ctx = canvas.getContext('2d');

            // Fill background
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, pageWidth, pageHeight);

            // Get selected page size
            let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
            let offsetX = 0, offsetY = 0;
            if (isScaled) {
                offsetX = (device.width - selectedPageWidth) / 2;
                offsetY = (device.height - selectedPageHeight) / 2;
            }

            // Draw gray centering margins if scaled
            if (offsetX > 0 || offsetY > 0) {
                ctx.fillStyle = centeringMarginColorSelect.value;
                ctx.fillRect(0, 0, offsetX, pageHeight); // Left
                ctx.fillRect(pageWidth - offsetX, 0, offsetX, pageHeight); // Right
                ctx.fillRect(0, 0, pageWidth, offsetY); // Top
                ctx.fillRect(0, pageHeight - offsetY, pageWidth, offsetY); // Bottom
            }

            // Draw white content area
            const contentX = isScaled ? offsetX : 0;
            const contentY = isScaled ? offsetY : 0;
            const contentWidth = isScaled ? selectedPageWidth : pageWidth;
            const contentHeight = isScaled ? selectedPageHeight : pageHeight;

            ctx.fillStyle = 'white';
            ctx.fillRect(contentX, contentY, contentWidth, contentHeight);

            // Convert SVG to image and draw it
            const svgData = new XMLSerializer().serializeToString(gridSvg);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function() {
                // Draw grid
                ctx.drawImage(img, contentX, contentY, contentWidth, contentHeight);

                // Calculate gutter for cumulative display
                let activeGutterLeft = 0;
                let activeGutterRight = 0;

                // Draw gutter margins first (at the edge)
                if (useGutterMarginsCheckbox.checked) {
                    const gutterLeft = parseFloat(gutterLeftSelect.value);
                    const gutterRight = parseFloat(gutterRightSelect.value);
                    const gutterWidth = isOddPage ? gutterLeft : gutterRight;

                    if (gutterWidth > 0) {
                        ctx.fillStyle = gutterColorSelect.value;
                        if (isOddPage) {
                            // Odd pages: gutter on left side
                            ctx.fillRect(contentX, contentY, gutterWidth, contentHeight);
                            activeGutterLeft = gutterWidth;
                        } else {
                            // Even pages: gutter on right side
                            ctx.fillRect(contentX + contentWidth - gutterWidth, contentY, gutterWidth, contentHeight);
                            activeGutterRight = gutterWidth;
                        }
                    }
                }

                // Draw filled margin areas (cumulative, after gutter)
                const marginTop = parseFloat(marginTopSelect.value);
                const marginBottom = parseFloat(marginBottomSelect.value);
                const marginLeft = parseFloat(marginLeftSelect.value);
                const marginRight = parseFloat(marginRightSelect.value);

                if (marginTop > 0 || marginBottom > 0 || marginLeft > 0 || marginRight > 0) {
                    ctx.fillStyle = marginColorSelect.value;

                    // Adjust margin positions to account for gutter
                    const marginContentX = contentX + activeGutterLeft;
                    const marginContentWidth = contentWidth - activeGutterLeft - activeGutterRight;

                    if (marginTop > 0) {
                        ctx.fillRect(marginContentX, contentY, marginContentWidth, marginTop);
                    }
                    if (marginBottom > 0) {
                        ctx.fillRect(marginContentX, contentY + contentHeight - marginBottom, marginContentWidth, marginBottom);
                    }
                    if (marginLeft > 0) {
                        ctx.fillRect(marginContentX, contentY, marginLeft, contentHeight);
                    }
                    if (marginRight > 0) {
                        ctx.fillRect(marginContentX + marginContentWidth - marginRight, contentY, marginRight, contentHeight);
                    }
                }

                // Add rulers if enabled
                if (showRulersCheckbox.checked) {
                    // Get full device dimensions for rulers
                    let labelToUse = pageSizeSelect.options[0].text;
                    const dimensionMatch = labelToUse.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
                    let widthInInches, heightInInches;
                    if (dimensionMatch) {
                        widthInInches = parseFloat(dimensionMatch[1]);
                        heightInInches = parseFloat(dimensionMatch[2]);
                    } else {
                        widthInInches = pageWidth / device.dpi;
                        heightInInches = pageHeight / device.dpi;
                    }

                    const pixelsPerInchWidth = pageWidth / widthInInches;
                    const pixelsPerInchHeight = pageHeight / heightInInches;

                    ctx.font = rulerFontSize + 'px Arial';
                    ctx.fillStyle = '#666';

                    // Left ruler (vertical)
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'middle';
                    for (let i = 0.25; i <= heightInInches; i += 0.25) {
                        const y = i * pixelsPerInchHeight;
                        const text = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                        ctx.fillText(text, 4, y);
                    }

                    // Bottom ruler (horizontal)
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'alphabetic';
                    for (let i = 0.25; i <= widthInInches; i += 0.25) {
                        const x = i * pixelsPerInchWidth;
                        const text = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                        ctx.fillText(text, x, pageHeight - 4);
                    }
                }

                // Add margin dimensions if enabled
                if (showMarginDimensionsCheckbox.checked) {
                    // Calculate usable dimensions
                    const selectedLabel = pageSizeSelect.options[pageSizeSelect.selectedIndex].text;
                    const dimensionMatch = selectedLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
                    let pageWidthInInches, pageHeightInInches;
                    if (dimensionMatch) {
                        pageWidthInInches = parseFloat(dimensionMatch[1]);
                        pageHeightInInches = parseFloat(dimensionMatch[2]);
                    } else {
                        const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                        const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                        pageWidthInInches = actualPageWidth / device.dpi;
                        pageHeightInInches = actualPageHeight / device.dpi;
                    }

                    const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                    const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                    const pixelsPerInchWidth = actualPageWidth / pageWidthInInches;
                    const pixelsPerInchHeight = actualPageHeight / pageHeightInInches;

                    const marginTopIn = marginTop / pixelsPerInchHeight;
                    const marginBottomIn = marginBottom / pixelsPerInchHeight;
                    const marginLeftIn = marginLeft / pixelsPerInchWidth;
                    const marginRightIn = marginRight / pixelsPerInchWidth;

                    const usableWidthIn = pageWidthInInches - marginLeftIn - marginRightIn;
                    const usableHeightIn = pageHeightInInches - marginTopIn - marginBottomIn;

                    ctx.font = 'bold ' + rulerFontSize + 'px Arial';
                    ctx.fillStyle = '#aaa';

                    // Top margin label - show usable width
                    if (marginTop >= 20) {
                        const x = contentX + contentWidth / 2;
                        const y = contentY + marginTop / 2;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(usableWidthIn.toFixed(2) + '"', x, y);
                    }

                    // Right margin label - show usable height (rotated)
                    if (marginRight >= 20) {
                        const x = contentX + contentWidth - marginRight / 2;
                        const y = contentY + contentHeight / 2;
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(usableHeightIn.toFixed(2) + '"', 0, 0);
                        ctx.restore();
                    }
                }

                // Add URL text if there's enough top margin
                if (marginTop >= 15) {
                    ctx.font = '10px Arial';
                    ctx.fillStyle = '#999';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText('https://srives.github.io/reMarkable/', contentX + contentWidth / 2, contentY + 5);
                }

                // Add margin text labels if enabled
                if (showMarginTextsCheckbox.checked) {
                    ctx.font = '11px Arial';
                    const marginContentX = contentX + activeGutterLeft;
                    const marginContentWidth = contentWidth - activeGutterLeft - activeGutterRight;

                    // 1. Device Centering Margins (top) - horizontal text
                    if (offsetY > 20) {
                        ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Device Centering Margins', pageWidth / 2, offsetY / 2);
                    }

                    ctx.fillStyle = 'rgba(100, 100, 100, 0.4)';

                    // 2. Gutter Margins
                    if (activeGutterLeft > 20) {
                        ctx.save();
                        ctx.translate(contentX + activeGutterLeft / 2, contentY + contentHeight / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Gutter Margins', 0, 0);
                        ctx.restore();
                    } else if (activeGutterRight > 20) {
                        ctx.save();
                        ctx.translate(contentX + contentWidth - activeGutterRight / 2, contentY + contentHeight / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Gutter Margins', 0, 0);
                        ctx.restore();
                    }

                    // 3. Content Margins - Top
                    if (marginTop > 20) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Content Margins', marginContentX + marginContentWidth / 2, contentY + marginTop / 2);
                    }

                    // 4. Content Margins - Bottom
                    if (marginBottom > 20) {
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Content Margins', marginContentX + marginContentWidth / 2, contentY + contentHeight - marginBottom / 2);
                    }

                    // 5. Content Margins - Left
                    if (marginLeft > 20) {
                        ctx.save();
                        ctx.translate(marginContentX + marginLeft / 2, contentY + contentHeight / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Content Margins', 0, 0);
                        ctx.restore();
                    }

                    // 6. Content Margins - Right
                    if (marginRight > 20) {
                        ctx.save();
                        ctx.translate(marginContentX + marginContentWidth - marginRight / 2, contentY + contentHeight / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('Content Margins', 0, 0);
                        ctx.restore();
                    }
                }

                // Convert canvas to PNG and download
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    URL.revokeObjectURL(svgUrl);
                }, 'image/png');
            };

            img.src = svgUrl;
        }

        async function saveMSWord() {
            // Check if JSZip library is loaded
            if (typeof JSZip === 'undefined') {
                alert('The document library is still loading. Please wait a moment and try again.');
                return;
            }

            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const dpi = isScaled ? device.dpi : device.unscaledDpi;
            const useGutters = useGutterMarginsCheckbox.checked;

            // Get margin values in pixels and convert to inches
            const marginTopPx = parseFloat(marginTopSelect.value);
            const marginBottomPx = parseFloat(marginBottomSelect.value);
            const marginLeftPx = parseFloat(marginLeftSelect.value);
            const marginRightPx = parseFloat(marginRightSelect.value);
            const gutterLeftPx = parseFloat(gutterLeftSelect.value);
            const gutterRightPx = parseFloat(gutterRightSelect.value);

            const marginTopIn = marginTopPx / dpi;
            const marginBottomIn = marginBottomPx / dpi;
            const marginLeftIn = marginLeftPx / dpi;
            const marginRightIn = marginRightPx / dpi;
            const gutterLeftIn = gutterLeftPx / dpi;
            const gutterRightIn = gutterRightPx / dpi;

            const selectedOption = pageSizeSelect.options[pageSizeSelect.selectedIndex];
            const pageLabel = selectedOption.textContent.trim();
            const filename = pageLabel
                .replace(/[^\w\s\-\(\)\.]/g, '')
                .replace(/\s+/g, '_')
                .replace(/_{2,}/g, '_') + '.docx';

            // Get target page size from selected option
            const dimensionMatch = pageLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
            let targetPageWidthIn = 8.5;  // Default
            let targetPageHeightIn = 11;  // Default
            if (dimensionMatch) {
                targetPageWidthIn = parseFloat(dimensionMatch[1]);
                targetPageHeightIn = parseFloat(dimensionMatch[2]);
            }

            // Convert inches to twips (1 inch = 1440 twips)
            const inchToTwip = 1440;

            // Determine paper size and calculate final margins
            let pageWidth, pageHeight;
            let finalMarginTop, finalMarginBottom, finalOddPageLeft, finalOddPageRight, finalEvenPageLeft, finalEvenPageRight;

            if (isScaled) {
                // When scaled, use 8.5 x 11 paper and add centering margins
                pageWidth = 8.5 * inchToTwip;
                pageHeight = 11 * inchToTwip;

                // Calculate centering margins to create the target page size within 8.5 x 11
                const centeringLeftRight = (8.5 - targetPageWidthIn) / 2;
                const centeringTopBottom = (11 - targetPageHeightIn) / 2;

                // Final margins = centering margins + content margins + gutter margins
                finalMarginTop = Math.round((centeringTopBottom + marginTopIn) * inchToTwip);
                finalMarginBottom = Math.round((centeringTopBottom + marginBottomIn) * inchToTwip);
                finalOddPageLeft = Math.round((centeringLeftRight + marginLeftIn + gutterLeftIn) * inchToTwip);
                finalOddPageRight = Math.round((centeringLeftRight + marginRightIn) * inchToTwip);
                finalEvenPageLeft = Math.round((centeringLeftRight + marginLeftIn) * inchToTwip);
                finalEvenPageRight = Math.round((centeringLeftRight + marginRightIn + gutterRightIn) * inchToTwip);
            } else {
                // When not scaled, use the target page size directly
                pageWidth = Math.round(targetPageWidthIn * inchToTwip);
                pageHeight = Math.round(targetPageHeightIn * inchToTwip);

                // Final margins = content margins + gutter margins only
                finalMarginTop = Math.round(marginTopIn * inchToTwip);
                finalMarginBottom = Math.round(marginBottomIn * inchToTwip);
                finalOddPageLeft = Math.round((marginLeftIn + gutterLeftIn) * inchToTwip);
                finalOddPageRight = Math.round(marginRightIn * inchToTwip);
                finalEvenPageLeft = Math.round(marginLeftIn * inchToTwip);
                finalEvenPageRight = Math.round((marginRightIn + gutterRightIn) * inchToTwip);
            }

            // Create ZIP file for DOCX
            const zip = new JSZip();

            // [Content_Types].xml
            zip.file('[Content_Types].xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
<Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
<Default Extension="xml" ContentType="application/xml"/>
<Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
<Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
<Override PartName="/word/settings.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"/>
<Override PartName="/word/footer1.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml"/>
</Types>`);

            // _rels/.rels
            zip.folder('_rels').file('.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>`);

            // word/_rels/document.xml.rels
            zip.folder('word').folder('_rels').file('document.xml.rels', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
<Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings" Target="settings.xml"/>
<Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer" Target="footer1.xml"/>
</Relationships>`);

            // Build document content with sections
            let documentContent = `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
<w:body>`;

            // Section 1: Cover Page (no page numbers)
            documentContent += `
<w:p>
<w:pPr>
<w:jc w:val="center"/>
<w:spacing w:before="2000" w:after="2000"/>
</w:pPr>
<w:r><w:rPr><w:b/><w:sz w:val="48"/></w:rPr><w:t>${pageLabel}</w:t></w:r>
</w:p>
<w:p>
<w:pPr>
<w:sectPr>
<w:pgSz w:w="${pageWidth}" w:h="${pageHeight}"/>
<w:pgMar w:top="${finalMarginTop}" w:right="${useGutters ? finalOddPageRight : finalOddPageRight}" w:bottom="${finalMarginBottom}" w:left="${useGutters ? finalOddPageLeft : finalOddPageLeft}" w:header="720" w:footer="720" w:gutter="0"/>
<w:titlePg/>
</w:sectPr>
</w:pPr>
</w:p>`;

            // Section 2: Front Matter
            documentContent += `
<w:p><w:r><w:t></w:t></w:r></w:p>
<w:p>
<w:pPr><w:jc w:val="center"/><w:spacing w:before="2000" w:after="1000"/></w:pPr>
<w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>Table of Contents</w:t></w:r>
</w:p>
<w:p><w:r><w:t></w:t></w:r></w:p>
<w:p>
<w:pPr><w:pageBreakBefore/><w:jc w:val="center"/><w:spacing w:before="2000" w:after="1000"/></w:pPr>
<w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>Dedication</w:t></w:r>
</w:p>
<w:p>
<w:pPr><w:jc w:val="center"/></w:pPr>
<w:r><w:t>https://srives.github.io/reMarkable/</w:t></w:r>
</w:p>
<w:p>
<w:pPr>
<w:sectPr>
<w:pgSz w:w="${pageWidth}" w:h="${pageHeight}"/>
<w:pgMar w:top="${finalMarginTop}" w:right="${useGutters ? finalEvenPageRight : finalEvenPageRight}" w:bottom="${finalMarginBottom}" w:left="${useGutters ? finalEvenPageLeft : finalEvenPageLeft}" w:header="720" w:footer="720" w:gutter="0"/>
</w:sectPr>
</w:pPr>
</w:p>`;

            // Section 3: Content with page numbers
            documentContent += `
<w:p>
<w:pPr><w:pageBreakBefore/><w:spacing w:before="2000" w:after="1000"/></w:pPr>
<w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>Chapter 1</w:t></w:r>
</w:p>
<w:p>
<w:r><w:t>Your content goes here. This is an odd page with the appropriate margins set.</w:t></w:r>
</w:p>`;

            if (useGutters) {
                documentContent += `
<w:p>
<w:pPr><w:pageBreakBefore/></w:pPr>
<w:r><w:t>Continued content on even page...</w:t></w:r>
</w:p>`;
            }

            // Final section properties with page numbers and odd/even margins
            documentContent += `
<w:sectPr>
<w:footerReference w:type="default" r:id="rId3"/>
<w:pgSz w:w="${pageWidth}" w:h="${pageHeight}"/>
<w:pgMar w:top="${finalMarginTop}" w:right="${useGutters ? finalOddPageRight : finalOddPageRight}" w:bottom="${finalMarginBottom}" w:left="${useGutters ? finalOddPageLeft : finalOddPageLeft}" w:header="720" w:footer="720" w:gutter="0"/>
<w:pgNumType w:start="1"/>
${useGutters ? '<w:rtlGutter/>' : ''}
</w:sectPr>
</w:body>
</w:document>`;

            zip.file('word/document.xml', documentContent);

            // word/styles.xml
            zip.file('word/styles.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:docDefaults>
<w:rPrDefault><w:rPr><w:rFonts w:ascii="Times New Roman" w:hAnsi="Times New Roman"/><w:sz w:val="24"/></w:rPr></w:rPrDefault>
</w:docDefaults>
</w:styles>`);

            // word/settings.xml with even/odd pages setting
            zip.file('word/settings.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:settings xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
${useGutters ? '<w:evenAndOddHeaders/>' : ''}
<w:defaultTabStop w:val="720"/>
</w:settings>`);

            // word/footer1.xml
            zip.file('word/footer1.xml', `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:ftr xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
<w:p>
<w:pPr><w:jc w:val="center"/></w:pPr>
<w:r><w:fldChar w:fldCharType="begin"/></w:r>
<w:r><w:instrText> PAGE </w:instrText></w:r>
<w:r><w:fldChar w:fldCharType="end"/></w:r>
</w:p>
</w:ftr>`);

            // Generate and save
            const blob = await zip.generateAsync({type: 'blob'});
            saveAs(blob, filename);
        }

        window.savePDF = savePDF;
        window.saveSVG = saveSVG;
        window.savePNG = savePNG;
        window.saveMSWord = saveMSWord;
        
        function generateGridSvg(pageWidth, pageHeight, gridSize, overlayMultiplier, templateType, isScaled, pageWidthInInches, pageHeightInInches) {
            gridSvg.innerHTML = '';
            gridSvg.style.display = 'none';

            // When not scaled, recalculate grid size based on physical dimensions
            let actualGridSize = gridSize;
            if (!isScaled) {
                // gridSize is in pixels based on scaled DPI, need to convert to physical inches then to unscaled pixels
                const device = devices[deviceTypeSelect.value];
                const gridSizeInInches = gridSize / device.dpi;
                const pixelsPerInch = pageHeight / pageHeightInInches; // Use height for consistency
                actualGridSize = gridSizeInInches * pixelsPerInch;
            }

            if (templateType === 'grid') {
                gridSvg.style.display = 'block';
                gridSvg.setAttribute('width', pageWidth);
                gridSvg.setAttribute('height', pageHeight);
                gridSvg.setAttribute('viewBox', `0 0 ${pageWidth} ${pageHeight}`);

                const overlaySize = actualGridSize * overlayMultiplier;

                for (let x = actualGridSize; x < pageWidth; x += actualGridSize) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', 0);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', pageHeight);
                    line.setAttribute('stroke', '#f5f5f5');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('shape-rendering', 'crispEdges');
                    gridSvg.appendChild(line);
                }

                for (let y = actualGridSize; y < pageHeight; y += actualGridSize) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', pageWidth);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#e8e8e8');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('shape-rendering', 'crispEdges');
                    gridSvg.appendChild(line);
                }

                if (overlayMultiplier > 0) {
                    for (let x = overlaySize; x < pageWidth; x += overlaySize) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', x);
                        line.setAttribute('y1', 0);
                        line.setAttribute('x2', x);
                        line.setAttribute('y2', pageHeight);
                        line.setAttribute('stroke', '#e8e8e8');
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('shape-rendering', 'crispEdges');
                        gridSvg.appendChild(line);
                    }

                    for (let y = overlaySize; y < pageHeight; y += overlaySize) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', 0);
                        line.setAttribute('y1', y);
                        line.setAttribute('x2', pageWidth);
                        line.setAttribute('y2', y);
                        line.setAttribute('stroke', '#d0d0d0');
                        line.setAttribute('stroke-width', '2');
                        line.setAttribute('shape-rendering', 'crispEdges');
                        gridSvg.appendChild(line);
                    }
                }
            } else if (templateType === 'lined') {
                gridSvg.style.display = 'block';
                gridSvg.setAttribute('width', pageWidth);
                gridSvg.setAttribute('height', pageHeight);
                gridSvg.setAttribute('viewBox', `0 0 ${pageWidth} ${pageHeight}`);

                for (let y = actualGridSize; y < pageHeight; y += actualGridSize) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', 0);
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', pageWidth);
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#d0d0d0');
                    line.setAttribute('stroke-width', '1.5');
                    line.setAttribute('shape-rendering', 'crispEdges');
                    gridSvg.appendChild(line);
                }
            } else if (templateType === 'dot-grid') {
                gridSvg.style.display = 'block';
                gridSvg.setAttribute('width', pageWidth);
                gridSvg.setAttribute('height', pageHeight);
                gridSvg.setAttribute('viewBox', `0 0 ${pageWidth} ${pageHeight}`);

                const overlaySize = actualGridSize * overlayMultiplier;

                for (let x = actualGridSize; x < pageWidth; x += actualGridSize) {
                    for (let y = actualGridSize; y < pageHeight; y += actualGridSize) {
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', x);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', '2');
                        circle.setAttribute('fill', '#c0c0c0');
                        gridSvg.appendChild(circle);
                    }
                }
                
                if (overlayMultiplier > 0) {
                    for (let x = overlaySize; x < pageWidth; x += overlaySize) {
                        for (let y = overlaySize; y < pageHeight; y += overlaySize) {
                            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            circle.setAttribute('cx', x);
                            circle.setAttribute('cy', y);
                            circle.setAttribute('r', '3');
                            circle.setAttribute('fill', '#a0a0a0');
                            gridSvg.appendChild(circle);
                        }
                    }
                }
            }
        }
        
        function updateRulers(offsetX = 0, offsetY = 0, selectedPageWidth = null, selectedPageHeight = null) {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';
            const showRulers = showRulersCheckbox.checked;

            // If not provided, get selectedPageWidth/Height from the dropdown
            if (selectedPageWidth === null || selectedPageHeight === null) {
                [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
            }

            // Calculate offset if not provided
            if (isScaled && offsetX === 0 && offsetY === 0) {
                offsetX = (device.width - selectedPageWidth) / 2;
                offsetY = (device.height - selectedPageHeight) / 2;
            }

            // Canvas size is ALWAYS full device dimensions
            let pageWidth = device.width;
            let pageHeight = device.height;

            if (showRulers) {
                rulerLeft.style.display = 'block';
                rulerBottom.style.display = 'block';

                // Rulers are children of contentArea but need to span the FULL device canvas
                // Position left ruler at absolute left edge (x=0) of device
                rulerLeft.style.position = 'absolute';
                rulerLeft.style.left = (-offsetX + 2) + 'px';  // Move to absolute left edge
                rulerLeft.style.top = (-offsetY) + 'px';  // Move to top of device
                rulerLeft.style.height = pageHeight + 'px';
                rulerLeft.style.fontSize = rulerFontSize + 'px';

                rulerBottom.style.position = 'absolute';
                rulerBottom.style.left = (-offsetX) + 'px';  // Align with left edge of device
                rulerBottom.style.bottom = 'auto';
                rulerBottom.style.top = (pageHeight - offsetY - 20) + 'px';  // Position at bottom of device
                rulerBottom.style.width = pageWidth + 'px';
                rulerBottom.style.fontSize = rulerFontSize + 'px';

                rulerLeft.innerHTML = '';
                rulerBottom.innerHTML = '';

                let widthInInches, heightInInches;

                // Rulers always show FULL DEVICE dimensions (topmost menu option)
                // This is the physical size of the device screen
                let labelToUse = pageSizeSelect.options[0].text;

                const dimensionMatch = labelToUse.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
                if (dimensionMatch) {
                    widthInInches = parseFloat(dimensionMatch[1]);
                    heightInInches = parseFloat(dimensionMatch[2]);
                } else {
                    // Fallback to device calculation
                    widthInInches = pageWidth / device.dpi;
                    heightInInches = pageHeight / device.dpi;
                }

                // Calculate pixel positions based on FULL DEVICE dimensions
                const pixelsPerInchWidth = pageWidth / widthInInches;
                const pixelsPerInchHeight = pageHeight / heightInInches;

                for (let i = 0.25; i <= heightInInches; i += 0.25) {
                    const mark = document.createElement('div');
                    mark.className = 'ruler-mark';
                    mark.textContent = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                    mark.style.top = (i * pixelsPerInchHeight) + 'px';
                    rulerLeft.appendChild(mark);
                }

                for (let i = 0.25; i <= widthInInches; i += 0.25) {
                    const mark = document.createElement('div');
                    mark.className = 'ruler-mark';
                    mark.textContent = i.toFixed(2).replace(/\.?0+$/, '') + '"';
                    mark.style.left = (i * pixelsPerInchWidth) + 'px';
                    rulerBottom.appendChild(mark);
                }
            } else {
                rulerLeft.style.display = 'none';
                rulerBottom.style.display = 'none';
            }
        }
        
        function updateUsableArea() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';

            // Canvas size is ALWAYS full device dimensions
            const pageWidth = device.width;
            const pageHeight = device.height;

            const marginTop = parseFloat(marginTopSelect.value);
            const marginBottom = parseFloat(marginBottomSelect.value);
            const marginLeft = parseFloat(marginLeftSelect.value);
            const marginRight = parseFloat(marginRightSelect.value);

            let pageWidthInInches, pageHeightInInches;

            // ALWAYS use the SELECTED page size for physical dimensions
            const selectedLabel = pageSizeSelect.options[pageSizeSelect.selectedIndex].text;
            const dimensionMatch = selectedLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
            if (dimensionMatch) {
                pageWidthInInches = parseFloat(dimensionMatch[1]);
                pageHeightInInches = parseFloat(dimensionMatch[2]);
            } else {
                // Fallback to device calculation
                let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
                const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                pageWidthInInches = actualPageWidth / device.dpi;
                pageHeightInInches = actualPageHeight / device.dpi;
            }

            // Get actual page dimensions for pixel-per-inch calculations
            let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
            const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
            const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;

            // Calculate pixels per inch
            const pixelsPerInchWidth = actualPageWidth / pageWidthInInches;
            const pixelsPerInchHeight = actualPageHeight / pageHeightInInches;

            // Calculate margin sizes in inches
            const marginTopIn = marginTop / pixelsPerInchHeight;
            const marginBottomIn = marginBottom / pixelsPerInchHeight;
            const marginLeftIn = marginLeft / pixelsPerInchWidth;
            const marginRightIn = marginRight / pixelsPerInchWidth;

            // Calculate usable area in inches
            const usableWidthIn = pageWidthInInches - marginLeftIn - marginRightIn;
            const usableHeightIn = pageHeightInInches - marginTopIn - marginBottomIn;

            // Display the result
            usableArea.textContent = `Usable Area: ${usableWidthIn.toFixed(2)}" × ${usableHeightIn.toFixed(2)}"`;
        }

        function updateDebugInfo() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';

            // Canvas size is ALWAYS full device dimensions
            const pageWidth = device.width;
            const pageHeight = device.height;

            let pageWidthInInches, pageHeightInInches;

            // ALWAYS use the SELECTED page size for physical dimensions
            const selectedLabel = pageSizeSelect.options[pageSizeSelect.selectedIndex].text;
            const dimensionMatch = selectedLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
            if (dimensionMatch) {
                pageWidthInInches = parseFloat(dimensionMatch[1]);
                pageHeightInInches = parseFloat(dimensionMatch[2]);
            } else {
                // Fallback to device calculation
                let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
                const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                pageWidthInInches = actualPageWidth / device.dpi;
                pageHeightInInches = actualPageHeight / device.dpi;
            }

            // Calculate outer margins (gray centering margins) in inches
            let [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);
            let offsetX = 0, offsetY = 0;
            if (isScaled) {
                offsetX = (device.width - selectedPageWidth) / 2;
                offsetY = (device.height - selectedPageHeight) / 2;
            }

            // Get full device dimensions in inches for outer margin calculation
            const fullDeviceLabel = pageSizeSelect.options[0].text;
            const fullDeviceDimMatch = fullDeviceLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
            let fullDeviceWidthIn, fullDeviceHeightIn;
            if (fullDeviceDimMatch) {
                fullDeviceWidthIn = parseFloat(fullDeviceDimMatch[1]);
                fullDeviceHeightIn = parseFloat(fullDeviceDimMatch[2]);
            } else {
                fullDeviceWidthIn = pageWidth / device.dpi;
                fullDeviceHeightIn = pageHeight / device.dpi;
            }

            const outerMarginX = offsetX / (pageWidth / fullDeviceWidthIn);
            const outerMarginY = offsetY / (pageHeight / fullDeviceHeightIn);

            // Calculate user-specified margins in inches
            const marginTop = parseFloat(marginTopSelect.value);
            const marginBottom = parseFloat(marginBottomSelect.value);
            const marginLeft = parseFloat(marginLeftSelect.value);
            const marginRight = parseFloat(marginRightSelect.value);

            const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
            const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
            const pixelsPerInchWidth = actualPageWidth / pageWidthInInches;
            const pixelsPerInchHeight = actualPageHeight / pageHeightInInches;

            const marginTopIn = marginTop / pixelsPerInchHeight;
            const marginBottomIn = marginBottom / pixelsPerInchHeight;
            const marginLeftIn = marginLeft / pixelsPerInchWidth;
            const marginRightIn = marginRight / pixelsPerInchWidth;

            // Total margins include outer margins + user-specified margins
            const totalMarginTop = outerMarginY + marginTopIn;
            const totalMarginBottom = outerMarginY + marginBottomIn;
            const totalMarginLeft = outerMarginX + marginLeftIn;
            const totalMarginRight = outerMarginX + marginRightIn;

            debugInfo.textContent = `Canvas: ${pageWidth}×${pageHeight}px | Physical: ${pageWidthInInches.toFixed(2)}"×${pageHeightInInches.toFixed(2)}" | Device Max: ${device.width}×${device.height}px | Outer: ${outerMarginX.toFixed(2)}"×${outerMarginY.toFixed(2)}" | Margins T:${totalMarginTop.toFixed(2)}" B:${totalMarginBottom.toFixed(2)}" L:${totalMarginLeft.toFixed(2)}" R:${totalMarginRight.toFixed(2)}"`;
        }
        
        function updateTemplate() {
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';

            // Canvas/contentArea is ALWAYS full device dimensions
            let pageWidth = device.width;
            let pageHeight = device.height;

            // But we need to know the selected page size for centering and grid drawing
            let selectedPageWidth, selectedPageHeight;
            [selectedPageWidth, selectedPageHeight] = pageSizeSelect.value.split(',').map(Number);

            // Calculate centering offset for gray margins (only when scaled)
            let offsetX = 0, offsetY = 0;
            if (isScaled) {
                offsetX = (device.width - selectedPageWidth) / 2;
                offsetY = (device.height - selectedPageHeight) / 2;
            }

            const marginTop = parseFloat(marginTopSelect.value);
            const marginBottom = parseFloat(marginBottomSelect.value);
            const marginLeft = parseFloat(marginLeftSelect.value);
            const marginRight = parseFloat(marginRightSelect.value);
            const gridSize = parseFloat(gridSizeSelect.value);
            const overlayMultiplier = parseInt(overlayGridSelect.value);
            const templateType = templateTypeSelect.value;

            // Position and size contentArea based on scaling mode
            if (isScaled) {
                // ContentArea is the selected page size, centered in the device canvas
                contentArea.style.width = selectedPageWidth + 'px';
                contentArea.style.height = selectedPageHeight + 'px';
                contentArea.style.left = offsetX + 'px';
                contentArea.style.top = offsetY + 'px';
            } else {
                // ContentArea fills the entire device
                contentArea.style.width = pageWidth + 'px';
                contentArea.style.height = pageHeight + 'px';
                contentArea.style.left = '0px';
                contentArea.style.top = '0px';
            }

            // Gray centering margins (only when scaled and page size < device size)
            if (offsetX > 0 || offsetY > 0) {
                const centeringColor = centeringMarginColorSelect.value;
                borderOverlay.style.boxShadow = `
                    inset ${offsetX}px 0 0 ${centeringColor},
                    inset -${offsetX}px 0 0 ${centeringColor},
                    inset 0 ${offsetY}px 0 ${centeringColor},
                    inset 0 -${offsetY}px 0 ${centeringColor}
                `;
            } else {
                borderOverlay.style.boxShadow = 'none';
            }
            
            contentArea.className = 'content-area ' + templateType;

            if (templateType === 'lined' || templateType === 'grid' || templateType === 'dot-grid') {
                gridSizeSelect.style.display = 'inline-block';
                gridSizeLabel.style.display = 'inline';
            } else {
                gridSizeSelect.style.display = 'none';
                gridSizeLabel.style.display = 'none';
            }

            if (templateType === 'grid' || templateType === 'dot-grid') {
                overlayGridSelect.style.display = 'inline-block';
                overlayGridLabel.style.display = 'inline';
            } else {
                overlayGridSelect.style.display = 'none';
                overlayGridLabel.style.display = 'none';
            }

            // Calculate physical dimensions for grid scaling and margin labels
            let pageWidthInInches, pageHeightInInches;

            // ALWAYS use the SELECTED page size for physical dimensions
            // This is the actual page being created (e.g., 6" × 9")
            const selectedLabel = pageSizeSelect.options[pageSizeSelect.selectedIndex].text;
            const dimensionMatch = selectedLabel.match(/\((\d+\.?\d*)"?\s*×\s*(\d+\.?\d*)"?\)/);
            if (dimensionMatch) {
                pageWidthInInches = parseFloat(dimensionMatch[1]);
                pageHeightInInches = parseFloat(dimensionMatch[2]);
            } else {
                // Fallback to device calculation
                const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
                const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;
                pageWidthInInches = actualPageWidth / device.dpi;
                pageHeightInInches = actualPageHeight / device.dpi;
            }

            // Grid and marginLines are positioned relative to contentArea
            // They should fill contentArea and let the borders define the pink margins
            gridSvg.style.left = '0px';
            gridSvg.style.top = '0px';
            gridSvg.style.width = '100%';
            gridSvg.style.height = '100%';

            // Generate grid with the appropriate dimensions
            if (isScaled) {
                generateGridSvg(selectedPageWidth, selectedPageHeight, gridSize, overlayMultiplier, templateType, isScaled, pageWidthInInches, pageHeightInInches);
            } else {
                generateGridSvg(pageWidth, pageHeight, gridSize, overlayMultiplier, templateType, isScaled, pageWidthInInches, pageHeightInInches);
            }

            // Calculate gutter width for cumulative margins
            let activeGutterLeft = 0;
            let activeGutterRight = 0;

            // Gutter margins (additional margin for binding side)
            if (useGutterMarginsCheckbox.checked) {
                const gutterLeft = parseFloat(gutterLeftSelect.value);
                const gutterRight = parseFloat(gutterRightSelect.value);
                const gutterColor = gutterColorSelect.value;

                // Show gutter based on page type
                const gutterWidth = isOddPage ? gutterLeft : gutterRight;

                if (gutterWidth > 0) {
                    gutterMargin.style.display = 'block';
                    gutterMargin.style.width = gutterWidth + 'px';
                    gutterMargin.style.backgroundColor = gutterColor;

                    if (isOddPage) {
                        // Odd pages: gutter on left side
                        gutterMargin.style.left = '0px';
                        gutterMargin.style.right = 'auto';
                        activeGutterLeft = gutterWidth;
                    } else {
                        // Even pages: gutter on right side
                        gutterMargin.style.left = 'auto';
                        gutterMargin.style.right = '0px';
                        activeGutterRight = gutterWidth;
                    }
                } else {
                    gutterMargin.style.display = 'none';
                }
            } else {
                gutterMargin.style.display = 'none';
            }

            // User-specified margins (borders on marginLines element)
            // Position marginLines to start AFTER the gutter (cumulative, not overlapping)
            marginLines.style.boxSizing = 'border-box';
            marginLines.style.left = activeGutterLeft + 'px';
            marginLines.style.right = activeGutterRight + 'px';
            marginLines.style.top = '0px';
            marginLines.style.bottom = '0px';

            if (marginTop > 0 || marginBottom > 0 || marginLeft > 0 || marginRight > 0) {
                marginLines.style.borderTopWidth = marginTop + 'px';
                marginLines.style.borderBottomWidth = marginBottom + 'px';
                marginLines.style.borderLeftWidth = marginLeft + 'px';
                marginLines.style.borderRightWidth = marginRight + 'px';
                marginLines.style.borderStyle = 'solid';
                marginLines.style.borderColor = marginColorSelect.value;

                marginLines.style.display = 'block';
            } else {
                marginLines.style.display = 'none';
            }

            // Position URL text in the top margin area (relative to contentArea)
            if (marginTop >= 15) {
                urlText.style.display = 'block';
                urlText.style.top = '5px';
                urlText.style.left = '50%';
            } else {
                urlText.style.display = 'none';
            }

            // Calculate physical dimensions and margins
            const actualPageWidth = isScaled ? selectedPageWidth : pageWidth;
            const actualPageHeight = isScaled ? selectedPageHeight : pageHeight;

            // Calculate pixels per inch
            const pixelsPerInchWidth = actualPageWidth / pageWidthInInches;
            const pixelsPerInchHeight = actualPageHeight / pageHeightInInches;

            // Calculate margin sizes in inches
            const marginTopIn = marginTop / pixelsPerInchHeight;
            const marginBottomIn = marginBottom / pixelsPerInchHeight;
            const marginLeftIn = marginLeft / pixelsPerInchWidth;
            const marginRightIn = marginRight / pixelsPerInchWidth;

            // Calculate usable area in inches
            const usableWidthIn = pageWidthInInches - marginLeftIn - marginRightIn;
            const usableHeightIn = pageHeightInInches - marginTopIn - marginBottomIn;

            const showDimensions = showMarginDimensionsCheckbox.checked;

            // Margin labels are positioned absolutely relative to templatePage, not contentArea
            // Top margin label - show usable width in the top margin area
            if (showDimensions && marginTop >= 20) {
                marginLabelTop.textContent = `${usableWidthIn.toFixed(2)}"`;
                marginLabelTop.style.display = 'block';
                marginLabelTop.style.top = (offsetY + marginTop / 2) + 'px';
                marginLabelTop.style.left = (offsetX + actualPageWidth / 2) + 'px';
                marginLabelTop.style.fontSize = rulerFontSize + 'px';
            } else {
                marginLabelTop.style.display = 'none';
            }

            // Right margin label - show usable height in the right margin area (vertical)
            if (showDimensions && marginRight >= 20) {
                marginLabelRight.textContent = `${usableHeightIn.toFixed(2)}"`;
                marginLabelRight.style.display = 'block';
                marginLabelRight.style.top = (offsetY + actualPageHeight / 2) + 'px';
                marginLabelRight.style.left = (offsetX + actualPageWidth - marginRight / 2) + 'px';
                marginLabelRight.style.fontSize = rulerFontSize + 'px';
            } else {
                marginLabelRight.style.display = 'none';
            }

            updateRulers(offsetX, offsetY, selectedPageWidth, selectedPageHeight);
            updateUsableArea();
            updateDebugInfo();
            updateMarginTexts(offsetX, offsetY, selectedPageWidth, selectedPageHeight, activeGutterLeft, activeGutterRight);
        }

        function updateMarginTexts(offsetX, offsetY, selectedPageWidth, selectedPageHeight, activeGutterLeft, activeGutterRight) {
            const showTexts = showMarginTextsCheckbox.checked;
            const device = devices[deviceTypeSelect.value];
            const isScaled = scaleTypeSelect.value === 'yes';

            if (!showTexts) {
                // Hide all margin texts
                centeringMarginTextTop.style.display = 'none';
                gutterMarginText.style.display = 'none';
                contentMarginTextTop.style.display = 'none';
                contentMarginTextBottom.style.display = 'none';
                contentMarginTextLeft.style.display = 'none';
                contentMarginTextRight.style.display = 'none';
                return;
            }

            const pageWidth = device.width;
            const pageHeight = device.height;
            const contentX = isScaled ? offsetX : 0;
            const contentY = isScaled ? offsetY : 0;
            const contentWidth = isScaled ? selectedPageWidth : pageWidth;
            const contentHeight = isScaled ? selectedPageHeight : pageHeight;

            const marginTop = parseFloat(marginTopSelect.value);
            const marginBottom = parseFloat(marginBottomSelect.value);
            const marginLeft = parseFloat(marginLeftSelect.value);
            const marginRight = parseFloat(marginRightSelect.value);

            // 1. Device Centering Margins (top) - horizontal text
            if (offsetY > 20) {
                centeringMarginTextTop.style.display = 'block';
                centeringMarginTextTop.style.left = (pageWidth / 2) + 'px';
                centeringMarginTextTop.style.top = (offsetY / 2) + 'px';
                centeringMarginTextTop.style.transform = 'translate(-50%, -50%)';
                centeringMarginTextTop.style.color = 'rgba(100, 100, 100, 0.3)';
            } else {
                centeringMarginTextTop.style.display = 'none';
            }

            // 2. Gutter Margins
            if (useGutterMarginsCheckbox.checked && activeGutterLeft > 20) {
                gutterMarginText.style.display = 'block';
                gutterMarginText.style.left = contentX + (activeGutterLeft / 2) + 'px';
                gutterMarginText.style.top = (contentY + contentHeight / 2) + 'px';
            } else if (useGutterMarginsCheckbox.checked && activeGutterRight > 20) {
                gutterMarginText.style.display = 'block';
                gutterMarginText.style.left = (contentX + contentWidth - activeGutterRight / 2) + 'px';
                gutterMarginText.style.top = (contentY + contentHeight / 2) + 'px';
            } else {
                gutterMarginText.style.display = 'none';
            }

            // 3. Content Margins - Top
            if (marginTop > 20) {
                contentMarginTextTop.style.display = 'block';
                contentMarginTextTop.style.left = (contentX + activeGutterLeft + (contentWidth - activeGutterLeft - activeGutterRight) / 2) + 'px';
                contentMarginTextTop.style.top = (contentY + marginTop / 2) + 'px';
            } else {
                contentMarginTextTop.style.display = 'none';
            }

            // 4. Content Margins - Bottom
            if (marginBottom > 20) {
                contentMarginTextBottom.style.display = 'block';
                contentMarginTextBottom.style.left = (contentX + activeGutterLeft + (contentWidth - activeGutterLeft - activeGutterRight) / 2) + 'px';
                contentMarginTextBottom.style.top = (contentY + contentHeight - marginBottom / 2) + 'px';
            } else {
                contentMarginTextBottom.style.display = 'none';
            }

            // 5. Content Margins - Left
            if (marginLeft > 20) {
                contentMarginTextLeft.style.display = 'block';
                contentMarginTextLeft.style.left = (contentX + activeGutterLeft + marginLeft / 2) + 'px';
                contentMarginTextLeft.style.top = (contentY + contentHeight / 2) + 'px';
            } else {
                contentMarginTextLeft.style.display = 'none';
            }

            // 6. Content Margins - Right
            if (marginRight > 20) {
                contentMarginTextRight.style.display = 'block';
                contentMarginTextRight.style.left = (contentX + contentWidth - activeGutterRight - marginRight / 2) + 'px';
                contentMarginTextRight.style.top = (contentY + contentHeight / 2) + 'px';
            } else {
                contentMarginTextRight.style.display = 'none';
            }
        }

        deviceTypeSelect.addEventListener('change', () => { updatePageSizes(); saveSettings(); });
        scaleTypeSelect.addEventListener('change', () => { updatePageSizes(); saveSettings(); });
        templateTypeSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        pageSizeSelect.addEventListener('change', () => {
            applyDefaultMargins();
            updateTemplate();
            updateRecommendation();
            saveSettings();
        });
        bindingTypeSelect.addEventListener('change', () => { updateRecommendation(); saveSettings(); });
        platformSelect.addEventListener('change', () => { updateRecommendation(); saveSettings(); });
        marginTopSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        marginBottomSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        marginLeftSelect.addEventListener('change', () => {
            marginRightSelect.value = marginLeftSelect.value;
            updateTemplate();
            saveSettings();
        });
        marginRightSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        marginColorSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        gridSizeSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        overlayGridSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        showRulersCheckbox.addEventListener('change', () => { updateRulers(); saveSettings(); });
        showMarginDimensionsCheckbox.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        useGutterMarginsCheckbox.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        gutterLeftSelect.addEventListener('change', () => {
            gutterRightSelect.value = gutterLeftSelect.value;
            updateTemplate();
            saveSettings();
        });
        gutterRightSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        gutterColorSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        showMarginTextsCheckbox.addEventListener('change', () => { updateTemplate(); saveSettings(); });
        centeringMarginColorSelect.addEventListener('change', () => { updateTemplate(); saveSettings(); });

        // Populate PDF page count dropdown
        for (let i = 1; i <= 400; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            if (i === 1) {
                option.selected = true;
            }
            pdfPageCount.appendChild(option);
        }

        pdfPageCount.addEventListener('change', saveSettings);

        // Load saved settings first
        loadSettings();

        // Then initialize the page
        updatePageSizes();
        updateRecommendation();
        updateUsableArea();
        updateDebugInfo();
        updateRulerSizeLabel();
        updateCenteringColorVisibility();
    </script>
</body>
</html>